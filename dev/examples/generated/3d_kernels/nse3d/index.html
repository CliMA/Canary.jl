<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>3D Compressible Navier-Stokes Equations · Canary.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../../../assets/documenter.js"></script><script src="../../../../siteinfo.js"></script><script src="../../../../../versions.js"></script><link href="../../../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Canary.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../../../">Home</a></li><li><a class="toctext" href="../../../../manual/dg_intro/">Introduction to DG</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../../../manual/mesh/">Mesh</a></li><li><a class="toctext" href="../../../../manual/metric/">Metric Terms</a></li><li><a class="toctext" href="../../../../manual/operators/">Element Operators</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../1d_kernels/LDG1d/">1D Diffusion Equation Example</a></li><li><a class="toctext" href="../../1d_kernels/burger1d/">1D Burgers Equation</a></li><li><a class="toctext" href="../../1d_kernels/swe1d/">1D Shallow Water Equations</a></li><li><a class="toctext" href="../../2d_kernels/LDG2d/">2D Diffusion Equation Example</a></li><li><a class="toctext" href="../../2d_kernels/swe2d/">2D Shallow Water Equations</a></li><li><a class="toctext" href="../../2d_kernels/nse2d/">2D Compressible Navier-Stokes Equations</a></li><li><a class="toctext" href="../LDG3d/">3D Diffusion Equation Example</a></li><li class="current"><a class="toctext" href>3D Compressible Navier-Stokes Equations</a><ul class="internal"><li><a class="toctext" href="#Introduction-1">Introduction</a></li><li><a class="toctext" href="#Continuous-Governing-Equations-1">Continuous Governing Equations</a></li><li><a class="toctext" href="#Discontinous-Galerkin-Method-1">Discontinous Galerkin Method</a></li><li><a class="toctext" href="#Local-Discontinous-Galerkin-Method-1">Local Discontinous Galerkin Method</a></li><li><a class="toctext" href="#Commented-Program-1">Commented Program</a></li></ul></li></ul></li><li><span class="toctext">API Reference</span><ul><li><a class="toctext" href="../../../../reference/mesh/">Mesh</a></li><li><a class="toctext" href="../../../../reference/metric/">Metric Terms</a></li><li><a class="toctext" href="../../../../reference/operators/">Element Operators</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Examples</li><li><a href>3D Compressible Navier-Stokes Equations</a></li></ul><a class="edit-page" href="https://github.com/climate-machine/Canary.jl/blob/master/examples/3d_kernels/nse3d.jl"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>3D Compressible Navier-Stokes Equations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="D-Compressible-Navier-Stokes-Equations-1" href="#D-Compressible-Navier-Stokes-Equations-1">3D Compressible Navier-Stokes Equations</a></h1><h2><a class="nav-anchor" id="Introduction-1" href="#Introduction-1">Introduction</a></h2><p>This example shows how to solve the 3D compressible Navier-Stokes equations using vanilla DG.</p><h2><a class="nav-anchor" id="Continuous-Governing-Equations-1" href="#Continuous-Governing-Equations-1">Continuous Governing Equations</a></h2><p>We solve the following equation:</p><div>\[\frac{\partial \rho}{\partial t} + \nabla \cdot \mathbf{U} = 0 \; \; (1.1)\]</div><div>\[\frac{\partial \mathbf{U}}{\partial t} + \nabla \cdot \left( \frac{\mathbf{U} \otimes \mathbf{U}}{\rho} + P \mathbf{I}_2 \right) + \rho g \hat{\mathbf{k}}= \nabla \cdot \mathbf{F}_U^{visc} \; \; (1.2)\]</div><div>\[\frac{\partial E}{\partial t} + \nabla \cdot \left( \frac{\mathbf{U} \left(E+P \right)}{\rho} \right) = \nabla \cdot \mathbf{F}_E^{visc} \; \; (1.3)\]</div><p>where <span>$\mathbf{u}=(u,v,w)$</span> is the velocity, <span>$\mathbf{U}=\rho \mathbf{u}$</span>, is the momentum, with <span>$\rho$</span> the total density and <span>$E=(\gamma-1) \rho \left( c_v T + \frac{1}{2} \mathbf{u} \cdot \mathbf{u} + g z \right)$</span> the total energy (internal <span>$+$</span> kinetic <span>$+$</span> potential). The viscous fluxes are defined as follows</p><div>\[\mathbf{F}_U^{visc} = \mu \left( \nabla \mathbf{u} +  \left( \nabla \mathbf{u} \right)^T + \lambda \left( \nabla \cdot \mathbf{u} \right)  \mathbf{I}_2 \right)\]</div><p>and</p><div>\[\mathbf{F}_E^{visc} =  \mathbf{u} \cdot \mathbf{F}_U^{visc} + \frac{c_p}{Pr} \nabla T\]</div><p>where <span>$\mu$</span> is the kinematic (or artificial) viscosity, <span>$\lambda=-\frac{2}{3}$</span> is the Stokes hypothesis, <span>$Pr \approx 0.71$</span> is the Prandtl number for air and <span>$T$</span> is the temperature. We employ periodic boundary conditions in the horizontaland no-flux boundary conditions in the vertical.  At the bottom and top of the domain, we need to impose no-flux boundary conditions in <span>$\nabla T$</span> to avoid a (artificial) thermal boundary layer.</p><h2><a class="nav-anchor" id="Discontinous-Galerkin-Method-1" href="#Discontinous-Galerkin-Method-1">Discontinous Galerkin Method</a></h2><p>To solve Eq. (1) we use the discontinuous Galerkin method with basis functions comprised of Lagrange polynomials based on Lobatto points. Multiplying Eq. (1) by a test function <span>$\psi$</span> and integrating within each element <span>$\Omega_e$</span> such that <span>$\Omega = \bigcup_{e=1}^{N_e} \Omega_e$</span> we get</p><div>\[\int_{\Omega_e} \psi \frac{\partial \mathbf{q}^{(e)}_N}{\partial t} d\Omega_e + \int_{\Omega_e} \psi \nabla \cdot \mathbf{F}^{(e)}_N d\Omega_e =  \int_{\Omega_e} \psi S\left( q^{(e)}_N \right) d\Omega_e \; \; (2)\]</div><p>where <span>$\mathbf{q}^{(e)}_N=\sum_{i=1}^{(N+1)^{dim}} \psi_i(\mathbf{x}) \mathbf{q}_i(t)$</span> is the finite dimensional expansion with basis functions <span>$\psi(\mathbf{x})$</span>, where <span>$\mathbf{q}=\left( \rho, \mathbf{U}^T, E \right)^T$</span>,</p><div>\[\mathbf{F}=\left( \mathbf{U}, \frac{\mathbf{U} \otimes \mathbf{U}}{\rho} + P \mathbf{I}_2,   \frac{\mathbf{U} \left(E+P \right)}{\rho} \right).\]</div><p>and</p><div>\[ S\left( q^{(e)}_N \right)  = \nu \left( 0, \nabla \cdot \mathbf{F}_U^{visc}, \nabla \cdot \mathbf{F}_E^{visc} \right).\]</div><p>Integrating Eq. (2) by parts yields</p><div>\[\int_{\Omega_e} \psi \frac{\partial \mathbf{q}^{(e)}_N}{\partial t} d\Omega_e + \int_{\Gamma_e} \psi \mathbf{n} \cdot \mathbf{F}^{(*,e)}_N d\Gamma_e - \int_{\Omega_e} \nabla \psi \cdot \mathbf{F}^{(e)}_N d\Omega_e = \int_{\Omega_e} \psi S\left( q^{(e)}_N \right) d\Omega_e \; \; (3)\]</div><p>where the second term on the left denotes the flux integral term (computed in &quot;function flux_rhs&quot;) and the third term denotes the volume integral term (computed in &quot;function volume_rhs&quot;).  The superscript <span>$(*,e)$</span> in the flux integral term denotes the numerical flux. Here we use the Rusanov flux.</p><h2><a class="nav-anchor" id="Local-Discontinous-Galerkin-Method-1" href="#Local-Discontinous-Galerkin-Method-1">Local Discontinous Galerkin Method</a></h2><p>To approximate the second order terms on the right hand side of Eq. (1) we use the local discontinuous Galerkin (LDG) method, which we described in LDG3d.jl. We will highlight the main steps below for completeness. We employ the following two-step process: first we approximate the gradient of <span>$q$</span> as follows</p><div>\[\mathbf{Q}(\mathbf{x}) = \nabla \mathbf{q}(\mathbf{x}) \; \; (4)\]</div><p>where <span>$\mathbf{Q}$</span> is an auxiliary vector function, followed by</p><div>\[\nabla \cdot \mathbf{F}^{visc}\left( \mathbf{Q} \right) \; \; (5)\]</div><p>which completes the approximation of the second order derivatives.</p><h2><a class="nav-anchor" id="Commented-Program-1" href="#Commented-Program-1">Commented Program</a></h2><div><pre><code class="language-julia">include(joinpath(@__DIR__,&quot;vtk.jl&quot;))
using MPI
using Canary
using Printf: @sprintf
const HAVE_CUDA = try
    using CUDAnative
    using CUDAdrv
    true
catch
    false
end
if HAVE_CUDA
    macro hascuda(ex)
        return :($(esc(ex)))
    end
else
    macro hascuda(ex)
        return :()
    end
end</code></pre><pre><code class="language-none">@hascuda (macro with 1 method)</code></pre></div><p>{{{ reshape for CuArray</p><div><pre><code class="language-julia">@hascuda function Base.reshape(A::CuArray, dims::NTuple{N, Int}) where {N}
    @assert prod(dims) == prod(size(A))
    CuArray{eltype(A), length(dims)}(dims, A.buf)
end</code></pre><pre><code class="language-none">()</code></pre></div><p>}}}</p><p>{{{ constants note the order of the fields below is also assumed in the code.</p><div><pre><code class="language-julia">const _nstate = 5
const _U, _V, _W, _ρ, _E = 1:_nstate
const stateid = (U = _U, V = _V, W = _W, ρ = _ρ, E = _E)

const _nvgeo = 14
const _ξx, _ηx, _ζx, _ξy, _ηy, _ζy, _ξz, _ηz, _ζz, _MJ, _MJI,
_x, _y, _z = 1:_nvgeo
const vgeoid = (ξx = _ξx, ηx = _ηx, ζx = _ζx,
                ξy = _ξy, ηy = _ηy, ζy = _ζy,
                ξz = _ξz, ηz = _ηz, ζz = _ζz,
                MJ = _MJ, MJI = _MJI,
                x = _x,   y = _y,   z = _z)

const _nsgeo = 5
const _nx, _ny, _nz, _sMJ, _vMJI = 1:_nsgeo
const sgeoid = (nx = _nx, ny = _ny, nz = _nz, sMJ = _sMJ, vMJI = _vMJI)

const _γ = 14  // 10
const _p0 = 100000
const _R_gas = 28717 // 100
const _c_p = 100467 // 100
const _c_v = 7175 // 10
const _gravity = 10
const _Prandtl = 71 // 10
const _Stokes = -2 // 3</code></pre><pre><code class="language-none">-2//3</code></pre></div><p>}}}</p><p>{{{ courant</p><div><pre><code class="language-julia">function courantnumber(::Val{dim}, ::Val{N}, vgeo, Q, mpicomm) where {dim, N}
    DFloat = eltype(Q)
    γ::DFloat       = _γ
    p0::DFloat      = _p0
    R_gas::DFloat   = _R_gas
    c_p::DFloat     = _c_p
    c_v::DFloat     = _c_v
    gravity::DFloat = _gravity

    Np = (N+1)^dim
    (~, ~, nelem) = size(Q)

    dt = [floatmax(DFloat)]
    Courant = - [floatmax(DFloat)]

    #Compute DT
    @inbounds for e = 1:nelem, n = 1:Np
        ρ, U, V, W, E = Q[n, _ρ, e], Q[n, _U, e], Q[n, _V, e], Q[n, _W, e], Q[n, _E, e]
        ξx, ξy, ξz = vgeo[n, _ξx, e], vgeo[n, _ξy, e], vgeo[n, _ξz, e]
        ηx, ηy, ηz = vgeo[n, _ηx, e], vgeo[n, _ηy, e], vgeo[n, _ηz, e]
        ζx, ζy, ζz = vgeo[n, _ζx, e], vgeo[n, _ζy, e], vgeo[n, _ζz, e]
        z = vgeo[n, _z, e]
        P = (R_gas/c_v)*(E - (U^2 + V^2 + W^2)/(2*ρ) - ρ*gravity*z)
        u, v, w = U/ρ, V/ρ, W/ρ
        dx=sqrt( (1.0/(2*ξx))^2 + 0*(1.0/(2*ηy))^2  + (1.0/(2*ζz))^2 )
        vel=sqrt( u^2 + v^2 + w^2)
        wave_speed = (vel + sqrt(γ * P / ρ))
        loc_dt = 1.0*dx/wave_speed/N
        dt[1] = min(dt[1], loc_dt)
    end
    dt_min=MPI.Allreduce(dt[1], MPI.MIN, mpicomm)

    #Compute Courant
    @inbounds for e = 1:nelem, n = 1:Np
        ρ, U, V, W, E = Q[n, _ρ, e], Q[n, _U, e], Q[n, _V, e], Q[n, _W, e], Q[n, _E, e]
        ξx, ξy, ξz = vgeo[n, _ξx, e], vgeo[n, _ξy, e], vgeo[n, _ξz, e]
        ηx, ηy, ηz = vgeo[n, _ηx, e], vgeo[n, _ηy, e], vgeo[n, _ηz, e]
        ζx, ζy, ζz = vgeo[n, _ζx, e], vgeo[n, _ζy, e], vgeo[n, _ζz, e]
        z = vgeo[n, _z, e]
        P = (R_gas/c_v)*(E - (U^2 + V^2 + W^2)/(2*ρ) - ρ*gravity*z)
        u, v, w = U/ρ, V/ρ, W/ρ
        dx=sqrt( (1.0/(2*ξx))^2 + 0*(1.0/(2*ηy))^2  + (1.0/(2*ζz))^2 )
        vel=sqrt( u^2 + v^2 + w^2)
        wave_speed = (vel + sqrt(γ * P / ρ))
        loc_Courant = wave_speed*dt_min*N/dx
        Courant[1] = max(Courant[1], loc_Courant)
    end
    Courant_max=MPI.Allreduce(Courant[1], MPI.MAX, mpicomm)

    (dt_min, Courant_max)
end</code></pre><pre><code class="language-none">courantnumber (generic function with 1 method)</code></pre></div><p>}}}</p><p>{{{ cfl</p><div><pre><code class="language-julia">function cfl(::Val{dim}, ::Val{N}, vgeo, Q, mpicomm) where {dim, N}
    DFloat = eltype(Q)
    γ::DFloat       = _γ
    p0::DFloat      = _p0
    R_gas::DFloat   = _R_gas
    c_p::DFloat     = _c_p
    c_v::DFloat     = _c_v
    gravity::DFloat = _gravity

    Np = (N+1)^dim
    (~, ~, nelem) = size(Q)

    dt = [floatmax(DFloat)]

    @inbounds for e = 1:nelem, n = 1:Np
        ρ, U, V, W = Q[n, _ρ, e], Q[n, _U, e], Q[n, _V, e], Q[n, _W, e]
        E = Q[n, _E, e]
        P = p0 * (R_gas * E / p0)^(c_p / c_v)

        ξx, ξy, ξz = vgeo[n, _ξx, e], vgeo[n, _ξy, e], vgeo[n, _ξz, e]
        ηx, ηy, ηz = vgeo[n, _ηx, e], vgeo[n, _ηy, e], vgeo[n, _ηz, e]
        ζx, ζy, ζz = vgeo[n, _ζx, e], vgeo[n, _ζy, e], vgeo[n, _ζz, e]

        loc_dt = 2ρ / max(abs(U * ξx + V * ξy + W * ξz) + ρ * sqrt(γ * P / ρ),
                          abs(U * ηx + V * ηy + W * ηz) + ρ * sqrt(γ * P / ρ),
                          abs(U * ζx + V * ζy + W * ζz) + ρ * sqrt(γ * P / ρ))
        dt[1] = min(dt[1], loc_dt)
    end

    MPI.Allreduce(dt[1], MPI.MIN, mpicomm)
end</code></pre><pre><code class="language-none">cfl (generic function with 1 method)</code></pre></div><p>}}}</p><p>{{{ compute geometry</p><div><pre><code class="language-julia">function computegeometry(::Val{dim}, mesh, D, ξ, ω, meshwarp, vmapM) where dim</code></pre></div><p>Compute metric terms</p><div><pre><code class="language-julia">    Nq = size(D, 1)
    DFloat = eltype(D)

    (nface, nelem) = size(mesh.elemtoelem)

    crd = creategrid(Val(dim), mesh.elemtocoord, ξ)

    vgeo = zeros(DFloat, Nq^dim, _nvgeo, nelem)
    sgeo = zeros(DFloat, _nsgeo, Nq^(dim-1), nface, nelem)

    (ξx, ηx, ζx, ξy, ηy, ζy, ξz, ηz, ζz, MJ, MJI, x, y, z) =
        ntuple(j-&gt;(@view vgeo[:, j, :]), _nvgeo)
    J = similar(x)
    (nx, ny, nz, sMJ, vMJI) = ntuple(j-&gt;(@view sgeo[ j, :, :, :]), _nsgeo)
    sJ = similar(sMJ)

    X = ntuple(j-&gt;(@view vgeo[:, _x+j-1, :]), dim)
    creategrid!(X..., mesh.elemtocoord, ξ)

    @inbounds for j = 1:length(x)
        (x[j], y[j], z[j]) = meshwarp(x[j], y[j], z[j])
    end</code></pre></div><p>Compute the metric terms</p><div><pre><code class="language-julia">    computemetric!(x, y, z, J, ξx, ηx, ζx, ξy, ηy, ζy, ξz, ηz, ζz, sJ,
                   nx, ny, nz, D)

    M = kron(1, ntuple(j-&gt;ω, dim)...)
    MJ .= M .* J
    MJI .= 1 ./ MJ
    vMJI .= MJI[vmapM]

    sM = dim &gt; 1 ? kron(1, ntuple(j-&gt;ω, dim-1)...) : one(DFloat)
    sMJ .= sM .* sJ

    (vgeo, sgeo)
end</code></pre><pre><code class="language-none">computegeometry (generic function with 1 method)</code></pre></div><p>}}}</p><p>{{{ CPU Kernels Volume RHS</p><div><pre><code class="language-julia">function volume_rhs!(::Val{dim}, ::Val{N}, rhs::Array, Q, vgeo, D, elems) where {dim, N}
    DFloat = eltype(Q)
    γ::DFloat       = _γ
    p0::DFloat      = _p0
    R_gas::DFloat   = _R_gas
    c_p::DFloat     = _c_p
    c_v::DFloat     = _c_v
    gravity::DFloat = _gravity

    Nq = N + 1
    nelem = size(Q)[end]

    Q = reshape(Q, Nq, Nq, Nq, _nstate, nelem)
    rhs = reshape(rhs, Nq, Nq, Nq, _nstate, nelem)
    vgeo = reshape(vgeo, Nq, Nq, Nq, _nvgeo, nelem)

    s_F = Array{DFloat}(undef, Nq, Nq, Nq, _nstate)
    s_G = Array{DFloat}(undef, Nq, Nq, Nq, _nstate)
    s_H = Array{DFloat}(undef, Nq, Nq, Nq, _nstate)

    @inbounds for e in elems
        for k = 1:Nq, j = 1:Nq, i = 1:Nq
            MJ = vgeo[i, j, k, _MJ, e]
            ξx, ξy, ξz = vgeo[i,j,k,_ξx,e], vgeo[i,j,k,_ξy,e], vgeo[i,j,k,_ξz,e]
            ηx, ηy, ηz = vgeo[i,j,k,_ηx,e], vgeo[i,j,k,_ηy,e], vgeo[i,j,k,_ηz,e]
            ζx, ζy, ζz = vgeo[i,j,k,_ζx,e], vgeo[i,j,k,_ζy,e], vgeo[i,j,k,_ζz,e]
            z = vgeo[i,j,k,_z,e]

            U, V, W = Q[i, j, k, _U, e], Q[i, j, k, _V, e], Q[i, j, k, _W, e]
            ρ, E = Q[i, j, k, _ρ, e], Q[i, j, k, _E, e]
            P = (R_gas/c_v)*(E - (U^2 + V^2 + W^2)/(2*ρ) - ρ*gravity*z)

            ρinv = 1 / ρ
            fluxρ_x = U
            fluxU_x = ρinv * U * U + P
            fluxV_x = ρinv * V * U
            fluxW_x = ρinv * W * U
            fluxE_x = ρinv * U * (E+P)

            fluxρ_y = V
            fluxU_y = ρinv * U * V
            fluxV_y = ρinv * V * V + P
            fluxW_y = ρinv * W * V
            fluxE_y = ρinv * V * (E+P)

            fluxρ_z = W
            fluxU_z = ρinv * U * W
            fluxV_z = ρinv * V * W
            fluxW_z = ρinv * W * W + P
            fluxE_z = ρinv * W * (E+P)

            s_F[i, j, k, _ρ] = MJ * (ξx * fluxρ_x + ξy * fluxρ_y + ξz * fluxρ_z)
            s_F[i, j, k, _U] = MJ * (ξx * fluxU_x + ξy * fluxU_y + ξz * fluxU_z)
            s_F[i, j, k, _V] = MJ * (ξx * fluxV_x + ξy * fluxV_y + ξz * fluxV_z)
            s_F[i, j, k, _W] = MJ * (ξx * fluxW_x + ξy * fluxW_y + ξz * fluxW_z)
            s_F[i, j, k, _E] = MJ * (ξx * fluxE_x + ξy * fluxE_y + ξz * fluxE_z)

            s_G[i, j, k, _ρ] = MJ * (ηx * fluxρ_x + ηy * fluxρ_y + ηz * fluxρ_z)
            s_G[i, j, k, _U] = MJ * (ηx * fluxU_x + ηy * fluxU_y + ηz * fluxU_z)
            s_G[i, j, k, _V] = MJ * (ηx * fluxV_x + ηy * fluxV_y + ηz * fluxV_z)
            s_G[i, j, k, _W] = MJ * (ηx * fluxW_x + ηy * fluxW_y + ηz * fluxW_z)
            s_G[i, j, k, _E] = MJ * (ηx * fluxE_x + ηy * fluxE_y + ηz * fluxE_z)

            s_H[i, j, k, _ρ] = MJ * (ζx * fluxρ_x + ζy * fluxρ_y + ζz * fluxρ_z)
            s_H[i, j, k, _U] = MJ * (ζx * fluxU_x + ζy * fluxU_y + ζz * fluxU_z)
            s_H[i, j, k, _V] = MJ * (ζx * fluxV_x + ζy * fluxV_y + ζz * fluxV_z)
            s_H[i, j, k, _W] = MJ * (ζx * fluxW_x + ζy * fluxW_y + ζz * fluxW_z)
            s_H[i, j, k, _E] = MJ * (ζx * fluxE_x + ζy * fluxE_y + ζz * fluxE_z)</code></pre></div><p>buoyancy term</p><div><pre><code class="language-julia">            rhs[i, j, k, _W, e] -= MJ * ρ * gravity
        end</code></pre></div><p>loop of ξ-grid lines</p><div><pre><code class="language-julia">        for s = 1:_nstate, k = 1:Nq, j = 1:Nq, i = 1:Nq, n = 1:Nq
            rhs[i, j, k, s, e] += D[n, i] * s_F[n, j, k, s]
        end</code></pre></div><p>loop of η-grid lines</p><div><pre><code class="language-julia">        for s = 1:_nstate, k = 1:Nq, j = 1:Nq, i = 1:Nq, n = 1:Nq
            rhs[i, j, k, s, e] += D[n, j] * s_G[i, n, k, s]
        end</code></pre></div><p>loop of ζ-grid lines</p><div><pre><code class="language-julia">        for s = 1:_nstate, k = 1:Nq, j = 1:Nq, i = 1:Nq, n = 1:Nq
            rhs[i, j, k, s, e] += D[n, k] * s_H[i, j, n, s]
        end
    end
end</code></pre><pre><code class="language-none">volume_rhs! (generic function with 1 method)</code></pre></div><p>flux RHS</p><div><pre><code class="language-julia">function flux_rhs!(::Val{dim}, ::Val{N}, rhs::Array, Q, sgeo, vgeo, elems, vmapM,
                  vmapP, elemtobndy) where {dim, N}
    DFloat = eltype(Q)
    γ::DFloat       = _γ
    p0::DFloat      = _p0
    R_gas::DFloat   = _R_gas
    c_p::DFloat     = _c_p
    c_v::DFloat     = _c_v
    gravity::DFloat = _gravity

    Np = (N+1)^dim
    Nfp = (N+1)^(dim-1)
    nface = 2*dim

    @inbounds for e in elems
        for f = 1:nface
            for n = 1:Nfp
                (nxM, nyM, nzM, sMJ, ~) = sgeo[:, n, f, e]
                idM, idP = vmapM[n, f, e], vmapP[n, f, e]

                eM, eP = e, ((idP - 1) ÷ Np) + 1
                vidM, vidP = ((idM - 1) % Np) + 1,  ((idP - 1) % Np) + 1

                #Left conservation variables
                ρM = Q[vidM, _ρ, eM]
                UM = Q[vidM, _U, eM]
                VM = Q[vidM, _V, eM]
                WM = Q[vidM, _W, eM]
                EM = Q[vidM, _E, eM]
                zM = vgeo[vidM, _z, eM]
                PM = (R_gas/c_v)*(EM - (UM^2 + VM^2 + WM^2)/(2*ρM) - ρM*gravity*zM)
                #Right conservation variables
                bc = elemtobndy[f, e]
                if bc == 0
                    ρP = Q[vidP, _ρ, eP]
                    UP = Q[vidP, _U, eP]
                    VP = Q[vidP, _V, eP]
                    WP = Q[vidP, _W, eP]
                    EP = Q[vidP, _E, eP]
                    zP = vgeo[vidP, _z, eP]
                    PP = (R_gas/c_v)*(EP - (UP^2 + VP^2 + WP^2)/(2*ρP) - ρP*gravity*zP)
                elseif bc == 1
                    UnM = nxM * UM + nyM * VM + nzM * WM
                    UP = UM - 2 * UnM * nxM
                    VP = VM - 2 * UnM * nyM
                    WP = WM - 2 * UnM * nzM
                    ρP = ρM
                    EP = EM
                    PP = PM
                else
                    error(&quot;Invalid boundary conditions $bc on face $f of element $e&quot;)
                end

                ρMinv = 1 / ρM
                fluxρM_x = UM
                fluxUM_x = ρMinv * UM * UM + PM
                fluxVM_x = ρMinv * VM * UM
                fluxWM_x = ρMinv * WM * UM
                fluxEM_x = ρMinv * UM * (EM+PM)

                fluxρM_y = VM
                fluxUM_y = ρMinv * UM * VM
                fluxVM_y = ρMinv * VM * VM + PM
                fluxWM_y = ρMinv * WM * VM
                fluxEM_y = ρMinv * VM * (EM+PM)

                fluxρM_z = WM
                fluxUM_z = ρMinv * UM * WM
                fluxVM_z = ρMinv * VM * WM
                fluxWM_z = ρMinv * WM * WM + PM
                fluxEM_z = ρMinv * WM * (EM+PM)

                ρPinv = 1 / ρP
                fluxρP_x = UP
                fluxUP_x = ρPinv * UP * UP + PP
                fluxVP_x = ρPinv * VP * UP
                fluxWP_x = ρPinv * WP * UP
                fluxEP_x = ρPinv * UP * (EP+PP)

                fluxρP_y = VP
                fluxUP_y = ρPinv * UP * VP
                fluxVP_y = ρPinv * VP * VP + PP
                fluxWP_y = ρPinv * WP * VP
                fluxEP_y = ρPinv * VP * (EP+PP)

                fluxρP_z = WP
                fluxUP_z = ρPinv * UP * WP
                fluxVP_z = ρPinv * VP * WP
                fluxWP_z = ρPinv * WP * WP + PP
                fluxEP_z = ρPinv * WP * (EP+PP)

                λM = ρMinv * abs(nxM * UM + nyM * VM + nzM * WM) + sqrt(ρMinv * γ * PM)
                λP = ρPinv * abs(nxM * UP + nyM * VP + nzM * WP) + sqrt(ρPinv * γ * PP)
                λ  =  max(λM, λP)

                #Compute Numerical Flux and Update
                fluxρS = (nxM * (fluxρM_x + fluxρP_x) + nyM * (fluxρM_y + fluxρP_y) +
                          nzM * (fluxρM_z + fluxρP_z) - λ * (ρP - ρM)) / 2
                fluxUS = (nxM * (fluxUM_x + fluxUP_x) + nyM * (fluxUM_y + fluxUP_y) +
                          nzM * (fluxUM_z + fluxUP_z) - λ * (UP - UM)) / 2
                fluxVS = (nxM * (fluxVM_x + fluxVP_x) + nyM * (fluxVM_y + fluxVP_y) +
                          nzM * (fluxVM_z + fluxVP_z) - λ * (VP - VM)) / 2
                fluxWS = (nxM * (fluxWM_x + fluxWP_x) + nyM * (fluxWM_y + fluxWP_y) +
                          nzM * (fluxWM_z + fluxWP_z) - λ * (WP - WM)) / 2
                fluxES = (nxM * (fluxEM_x + fluxEP_x) + nyM * (fluxEM_y + fluxEP_y) +
                          nzM * (fluxEM_z + fluxEP_z) - λ * (EP - EM)) / 2


                #Update RHS
                rhs[vidM, _ρ, eM] -= sMJ * fluxρS
                rhs[vidM, _U, eM] -= sMJ * fluxUS
                rhs[vidM, _V, eM] -= sMJ * fluxVS
                rhs[vidM, _W, eM] -= sMJ * fluxWS
                rhs[vidM, _E, eM] -= sMJ * fluxES
            end
        end
    end
end</code></pre><pre><code class="language-none">flux_rhs! (generic function with 1 method)</code></pre></div><p>}}}</p><p>{{{ Volume grad(Q)</p><div><pre><code class="language-julia">function volume_grad!(::Val{dim}, ::Val{N}, rhs::Array, Q, vgeo, D, elems) where {dim, N}
    DFloat = eltype(Q)
    γ::DFloat       = _γ
    p0::DFloat      = _p0
    R_gas::DFloat   = _R_gas
    c_p::DFloat     = _c_p
    c_v::DFloat     = _c_v
    gravity::DFloat = _gravity

    Nq = N + 1
    nelem = size(Q)[end]

    Q = reshape(Q, Nq, Nq, Nq, _nstate, nelem)
    rhs = reshape(rhs, Nq, Nq, Nq, _nstate, dim, nelem)
    vgeo = reshape(vgeo, Nq, Nq, Nq, _nvgeo, nelem)

    #Initialize RHS vector
    fill!( rhs, zero(rhs[1]))

    #Allocate Arrays
    s_F = Array{DFloat}(undef, Nq, Nq, Nq, _nstate, dim)
    s_G = Array{DFloat}(undef, Nq, Nq, Nq, _nstate, dim)
    s_H = Array{DFloat}(undef, Nq, Nq, Nq, _nstate, dim)

    @inbounds for e in elems
        for k = 1:Nq, j = 1:Nq, i = 1:Nq
            MJ = vgeo[i, j, k, _MJ, e]
            ξx, ξy, ξz = vgeo[i,j,k,_ξx,e], vgeo[i,j,k,_ξy,e], vgeo[i,j,k,_ξz,e]
            ηx, ηy, ηz = vgeo[i,j,k,_ηx,e], vgeo[i,j,k,_ηy,e], vgeo[i,j,k,_ηz,e]
            ζx, ζy, ζz = vgeo[i,j,k,_ζx,e], vgeo[i,j,k,_ζy,e], vgeo[i,j,k,_ζz,e]
            z = vgeo[i,j,k,_z,e]

            U, V, W = Q[i, j, k, _U, e], Q[i, j, k, _V, e], Q[i, j, k, _W, e]
            ρ, E = Q[i, j, k, _ρ, e], Q[i, j, k, _E, e]
            P = (R_gas/c_v)*(E - (U^2 + V^2 + W^2)/(2*ρ) - ρ*gravity*z)

            #Primitive variables
            u=U/ρ
            v=V/ρ
            w=W/ρ
            T=P/(R_gas*ρ)

            #Compute fluxes
            fluxρ = ρ
            fluxU = u
            fluxV = v
            fluxW = w
            fluxE = T

            s_F[i, j, k, _ρ, 1], s_F[i, j, k, _ρ, 2], s_F[i, j, k, _ρ, 3] = MJ * (ξx * fluxρ), MJ * (ξy * fluxρ), MJ * (ξz * fluxρ)
            s_F[i, j, k, _U, 1], s_F[i, j, k, _U, 2], s_F[i, j, k, _U, 3] = MJ * (ξx * fluxU), MJ * (ξy * fluxU), MJ * (ξz * fluxU)
            s_F[i, j, k, _V, 1], s_F[i, j, k, _V, 2], s_F[i, j, k, _V, 3] = MJ * (ξx * fluxV), MJ * (ξy * fluxV), MJ * (ξz * fluxV)
            s_F[i, j, k, _W, 1], s_F[i, j, k, _W, 2], s_F[i, j, k, _W, 3] = MJ * (ξx * fluxW), MJ * (ξy * fluxW), MJ * (ξz * fluxW)
            s_F[i, j, k, _E, 1], s_F[i, j, k, _E, 2], s_F[i, j, k, _E, 3] = MJ * (ξx * fluxE), MJ * (ξy * fluxE), MJ * (ξz * fluxE)

            s_G[i, j, k, _ρ, 1], s_G[i, j, k, _ρ, 2], s_G[i, j, k, _ρ, 3] = MJ * (ηx * fluxρ), MJ * (ηy * fluxρ), MJ * (ηz * fluxρ)
            s_G[i, j, k, _U, 1], s_G[i, j, k, _U, 2], s_G[i, j, k, _U, 3] = MJ * (ηx * fluxU), MJ * (ηy * fluxU), MJ * (ηz * fluxU)
            s_G[i, j, k, _V, 1], s_G[i, j, k, _V, 2], s_G[i, j, k, _V, 3] = MJ * (ηx * fluxV), MJ * (ηy * fluxV), MJ * (ηz * fluxV)
            s_G[i, j, k, _W, 1], s_G[i, j, k, _W, 2], s_G[i, j, k, _W, 3] = MJ * (ηx * fluxW), MJ * (ηy * fluxW), MJ * (ηz * fluxW)
            s_G[i, j, k, _E, 1], s_G[i, j, k, _E, 2], s_G[i, j, k, _E, 3] = MJ * (ηx * fluxE), MJ * (ηy * fluxE), MJ * (ηz * fluxE)

            s_H[i, j, k, _ρ, 1], s_H[i, j, k, _ρ, 2], s_H[i, j, k, _ρ, 3] = MJ * (ζx * fluxρ), MJ * (ζy * fluxρ), MJ * (ζz * fluxρ)
            s_H[i, j, k, _U, 1], s_H[i, j, k, _U, 2], s_H[i, j, k, _U, 3] = MJ * (ζx * fluxU), MJ * (ζy * fluxU), MJ * (ζz * fluxU)
            s_H[i, j, k, _V, 1], s_H[i, j, k, _V, 2], s_H[i, j, k, _V, 3] = MJ * (ζx * fluxV), MJ * (ζy * fluxV), MJ * (ζz * fluxV)
            s_H[i, j, k, _W, 1], s_H[i, j, k, _W, 2], s_H[i, j, k, _W, 3] = MJ * (ζx * fluxW), MJ * (ζy * fluxW), MJ * (ζz * fluxW)
            s_H[i, j, k, _E, 1], s_H[i, j, k, _E, 2], s_H[i, j, k, _E, 3] = MJ * (ζx * fluxE), MJ * (ζy * fluxE), MJ * (ζz * fluxE)
        end</code></pre></div><p>loop of ξ-grid lines</p><div><pre><code class="language-julia">        for s = 1:_nstate, k = 1:Nq, j = 1:Nq, i = 1:Nq, n = 1:Nq
            rhs[i, j, k, s, 1, e] -= D[n, i] * s_F[n, j, k, s, 1]
            rhs[i, j, k, s, 2, e] -= D[n, i] * s_F[n, j, k, s, 2]
            rhs[i, j, k, s, 3, e] -= D[n, i] * s_F[n, j, k, s, 3]
        end</code></pre></div><p>loop of η-grid lines</p><div><pre><code class="language-julia">        for s = 1:_nstate, k = 1:Nq, j = 1:Nq, i = 1:Nq, n = 1:Nq
            rhs[i, j, k, s, 1, e] -= D[n, j] * s_G[i, n, k, s, 1]
            rhs[i, j, k, s, 2, e] -= D[n, j] * s_G[i, n, k, s, 2]
            rhs[i, j, k, s, 3, e] -= D[n, j] * s_G[i, n, k, s, 3]
        end</code></pre></div><p>loop of ζ-grid lines</p><div><pre><code class="language-julia">        for s = 1:_nstate, k = 1:Nq, j = 1:Nq, i = 1:Nq, n = 1:Nq
            rhs[i, j, k, s, 1, e] -= D[n, k] * s_H[i, j, n, s, 1]
            rhs[i, j, k, s, 2, e] -= D[n, k] * s_H[i, j, n, s, 2]
            rhs[i, j, k, s, 3, e] -= D[n, k] * s_H[i, j, n, s, 3]
        end
    end
end</code></pre><pre><code class="language-none">volume_grad! (generic function with 1 method)</code></pre></div><p>}}}</p><p>Flux grad(Q)</p><div><pre><code class="language-julia">function flux_grad!(::Val{dim}, ::Val{N}, rhs::Array,  Q, sgeo, vgeo, elems, vmapM, vmapP, elemtobndy) where {dim, N}
    DFloat = eltype(Q)
    γ::DFloat       = _γ
    p0::DFloat      = _p0
    R_gas::DFloat   = _R_gas
    c_p::DFloat     = _c_p
    c_v::DFloat     = _c_v
    gravity::DFloat = _gravity

    Np = (N+1)^dim
    Nfp = (N+1)^(dim-1)
    nface = 2*dim

    @inbounds for e in elems
        for f = 1:nface
            for n = 1:Nfp
                (nxM, nyM, nzM, sMJ, ~) = sgeo[:, n, f, e]
                idM, idP = vmapM[n, f, e], vmapP[n, f, e]

                eM, eP = e, ((idP - 1) ÷ Np) + 1
                vidM, vidP = ((idM - 1) % Np) + 1,  ((idP - 1) % Np) + 1

                #Left variables
                ρM = Q[vidM, _ρ, eM]
                UM = Q[vidM, _U, eM]
                VM = Q[vidM, _V, eM]
                WM = Q[vidM, _W, eM]
                EM = Q[vidM, _E, eM]
                zM = vgeo[vidM, _z, eM]
                PM = (R_gas/c_v)*(EM - (UM^2 + VM^2 + WM^2)/(2*ρM) - ρM*gravity*zM)
                uM=UM/ρM
                vM=VM/ρM
                wM=WM/ρM
                TM=PM/(R_gas*ρM)

                #Right variables
                bc = elemtobndy[f, e]
                ρP = UP = VP = WP = EP = PP = zero(eltype(Q))
                if bc == 0
                    ρP = Q[vidP, _ρ, eP]
                    UP = Q[vidP, _U, eP]
                    VP = Q[vidP, _V, eP]
                    WP = Q[vidP, _W, eP]
                    EP = Q[vidP, _E, eP]
                    zP = vgeo[vidP, _z, eP]
                    PP = (R_gas/c_v)*(EP - (UP^2 + VP^2 + WP^2)/(2*ρP) - ρP*gravity*zP)
                    uP=UP/ρP
                    vP=VP/ρP
                    wP=WP/ρP
                    TP=PP/(R_gas*ρP)
                elseif bc == 1
                    UnM = nxM * UM + nyM * VM + nzM * WM
                    UP = UM - 2 * UnM * nxM
                    VP = VM - 2 * UnM * nyM
                    WP = WM - 2 * UnM * nzM
                    ρP = ρM
                    EP = EM
                    PP = PM
                    uP=UP/ρP
                    vP=VP/ρP
                    wP=WP/ρP
                    TP=TM
                else
                    error(&quot;Invalid boundary conditions $bc on face $f of element $e&quot;)
                end

                #Left Fluxes
                fluxρM = ρM
                fluxUM = uM
                fluxVM = vM
                fluxWM = wM
                fluxEM = TM

                #Right Fluxes
                fluxρP = ρP
                fluxUP = uP
                fluxVP = vP
                fluxWP = wP
                fluxEP = TP

                #Compute Numerical/Rusanov Flux
                fluxρS = 0.5*(fluxρM + fluxρP)
                fluxUS = 0.5*(fluxUM + fluxUP)
                fluxVS = 0.5*(fluxVM + fluxVP)
                fluxWS = 0.5*(fluxWM + fluxWP)
                fluxES = 0.5*(fluxEM + fluxEP)

                #Update RHS
                rhs[vidM, _ρ, 1, eM] += sMJ * nxM*fluxρS
                rhs[vidM, _ρ, 2, eM] += sMJ * nyM*fluxρS
                rhs[vidM, _ρ, 3, eM] += sMJ * nzM*fluxρS
                rhs[vidM, _U, 1, eM] += sMJ * nxM*fluxUS
                rhs[vidM, _U, 2, eM] += sMJ * nyM*fluxUS
                rhs[vidM, _U, 3, eM] += sMJ * nzM*fluxUS
                rhs[vidM, _V, 1, eM] += sMJ * nxM*fluxVS
                rhs[vidM, _V, 2, eM] += sMJ * nyM*fluxVS
                rhs[vidM, _V, 3, eM] += sMJ * nzM*fluxVS
                rhs[vidM, _W, 1, eM] += sMJ * nxM*fluxWS
                rhs[vidM, _W, 2, eM] += sMJ * nyM*fluxWS
                rhs[vidM, _W, 3, eM] += sMJ * nzM*fluxWS
                rhs[vidM, _E, 1, eM] += sMJ * nxM*fluxES
                rhs[vidM, _E, 2, eM] += sMJ * nyM*fluxES
                rhs[vidM, _E, 3, eM] += sMJ * nzM*fluxES
            end
        end
    end
end</code></pre><pre><code class="language-none">flux_grad! (generic function with 1 method)</code></pre></div><p>}}}</p><p>{{{ Volume div(grad(Q))</p><div><pre><code class="language-julia">function volume_div!(::Val{dim}, ::Val{N}, rhs::Array, gradQ, Q, vgeo, D, elems) where {dim, N}
    DFloat = eltype(Q)
    γ::DFloat       = _γ
    p0::DFloat      = _p0
    R_gas::DFloat   = _R_gas
    c_p::DFloat     = _c_p
    c_v::DFloat     = _c_v
    gravity::DFloat = _gravity
    Pr::DFloat = _Prandtl
    lambda::DFloat = _Stokes

    Nq = N + 1
    nelem = size(Q)[end]

    Q = reshape(Q, Nq, Nq, Nq, _nstate, nelem)
    gradQ = reshape(gradQ, Nq, Nq, Nq, _nstate, dim, nelem)
    rhs = reshape(rhs, Nq, Nq, Nq, _nstate, dim, nelem)
    vgeo = reshape(vgeo, Nq, Nq, Nq, _nvgeo, nelem)

    #Initialize RHS vector
    fill!( rhs, zero(rhs[1]))

    #Allocate Arrays
    s_F = Array{DFloat}(undef, Nq, Nq, Nq, _nstate)
    s_G = Array{DFloat}(undef, Nq, Nq, Nq, _nstate)
    s_H = Array{DFloat}(undef, Nq, Nq, Nq, _nstate)

    @inbounds for e in elems
        for k = 1:Nq, j = 1:Nq, i = 1:Nq
            MJ = vgeo[i, j, k, _MJ, e]
            ξx, ξy, ξz = vgeo[i,j,k,_ξx,e], vgeo[i,j,k,_ξy,e], vgeo[i,j,k,_ξz,e]
            ηx, ηy, ηz = vgeo[i,j,k,_ηx,e], vgeo[i,j,k,_ηy,e], vgeo[i,j,k,_ηz,e]
            ζx, ζy, ζz = vgeo[i,j,k,_ζx,e], vgeo[i,j,k,_ζy,e], vgeo[i,j,k,_ζz,e]

            ρx, ρy, ρz = gradQ[i,j,k,_ρ,1,e], gradQ[i,j,k,_ρ,2,e], gradQ[i,j,k,_ρ,3,e]
            Ux, Uy, Uz = gradQ[i,j,k,_U,1,e], gradQ[i,j,k,_U,2,e], gradQ[i,j,k,_U,3,e]
            Vx, Vy, Vz = gradQ[i,j,k,_V,1,e], gradQ[i,j,k,_V,2,e], gradQ[i,j,k,_V,3,e]
            Wx, Wy, Wz = gradQ[i,j,k,_W,1,e], gradQ[i,j,k,_W,2,e], gradQ[i,j,k,_W,3,e]
            Ex, Ey, Ez = gradQ[i,j,k,_E,1,e], gradQ[i,j,k,_E,2,e], gradQ[i,j,k,_E,3,e]
            ρ, U, V, W= Q[i,j,k,_ρ,e], Q[i,j,k,_U,e], Q[i,j,k,_V,e], Q[i,j,k,_W,e]

            #Compute primitive variables
            ux, uy, uz = Ux, Uy, Uz
            vx, vy, vz = Vx, Vy, Vz
            wx, wy, wz = Wx, Wy, Wz
            Tx, Ty, Tz = Ex, Ey, Ez
            div_u=ux + vy + wz
            u=U/ρ
            v=V/ρ
            w=W/ρ

            #Compute fluxes
            fluxρ_x = 0*ρx
            fluxρ_y = 0*ρy
            fluxρ_z = 0*ρz
            fluxU_x = 2*ux + lambda*div_u
            fluxU_y = uy + vx
            fluxU_z = uz + wx
            fluxV_x = vx + uy
            fluxV_y = 2*vy + lambda*div_u
            fluxV_z = vz + wy
            fluxW_x = wx + uz
            fluxW_y = wy + vz
            fluxW_z = 2*wz + lambda*div_u
            fluxE_x = u*(2*ux + lambda*div_u) + v*(uy + vx) + w*(uz + wx) + c_p/Pr*Tx
            fluxE_y = u*(vx + uy) + v*(2*vy + lambda*div_u) + w*(vz + wy) + c_p/Pr*Ty
            fluxE_z = u*(wx + uz) + v*(wy + vz) + w*(2*wz + lambda*div_u) + c_p/Pr*Tz

            s_F[i, j, k, _ρ] = MJ * (ξx * fluxρ_x + ξy * fluxρ_y + ξz * fluxρ_z)
            s_F[i, j, k, _U] = MJ * (ξx * fluxU_x + ξy * fluxU_y + ξz * fluxU_z)
            s_F[i, j, k, _V] = MJ * (ξx * fluxV_x + ξy * fluxV_y + ξz * fluxV_z)
            s_F[i, j, k, _W] = MJ * (ξx * fluxW_x + ξy * fluxW_y + ξz * fluxW_z)
            s_F[i, j, k, _E] = MJ * (ξx * fluxE_x + ξy * fluxE_y + ξz * fluxE_z)

            s_G[i, j, k, _ρ] = MJ * (ηx * fluxρ_x + ηy * fluxρ_y + ηz * fluxρ_z)
            s_G[i, j, k, _U] = MJ * (ηx * fluxU_x + ηy * fluxU_y + ηz * fluxU_z)
            s_G[i, j, k, _V] = MJ * (ηx * fluxV_x + ηy * fluxV_y + ηz * fluxV_z)
            s_G[i, j, k, _W] = MJ * (ηx * fluxW_x + ηy * fluxW_y + ηz * fluxW_z)
            s_G[i, j, k, _E] = MJ * (ηx * fluxE_x + ηy * fluxE_y + ηz * fluxE_z)

            s_H[i, j, k, _ρ] = MJ * (ζx * fluxρ_x + ζy * fluxρ_y + ζz * fluxρ_z)
            s_H[i, j, k, _U] = MJ * (ζx * fluxU_x + ζy * fluxU_y + ζz * fluxU_z)
            s_H[i, j, k, _V] = MJ * (ζx * fluxV_x + ζy * fluxV_y + ζz * fluxV_z)
            s_H[i, j, k, _W] = MJ * (ζx * fluxW_x + ζy * fluxW_y + ζz * fluxW_z)
            s_H[i, j, k, _E] = MJ * (ζx * fluxE_x + ζy * fluxE_y + ζz * fluxE_z)
        end</code></pre></div><p>loop of ξ-grid lines</p><div><pre><code class="language-julia">        for s = 1:_nstate, k = 1:Nq, j = 1:Nq, i = 1:Nq, n = 1:Nq
            rhs[i, j, k, s, 1, e] -= D[n, i] * s_F[n, j, k, s]
        end</code></pre></div><p>loop of η-grid lines</p><div><pre><code class="language-julia">        for s = 1:_nstate, k = 1:Nq, j = 1:Nq, i = 1:Nq, n = 1:Nq
            rhs[i, j, k, s, 1, e] -= D[n, j] * s_G[i, n, k, s]
        end</code></pre></div><p>loop of ζ-grid lines</p><div><pre><code class="language-julia">        for s = 1:_nstate, k = 1:Nq, j = 1:Nq, i = 1:Nq, n = 1:Nq
            rhs[i, j, k, s, 1, e] -= D[n, k] * s_H[i, j, n, s]
        end
    end
end</code></pre><pre><code class="language-none">volume_div! (generic function with 1 method)</code></pre></div><p>}}}</p><p>Flux div(grad(Q))</p><div><pre><code class="language-julia">function flux_div!(::Val{dim}, ::Val{N}, rhs::Array,  gradQ, Q, sgeo, elems, vmapM, vmapP, elemtobndy) where {dim, N}
    DFloat = eltype(Q)
    γ::DFloat       = _γ
    p0::DFloat      = _p0
    R_gas::DFloat   = _R_gas
    c_p::DFloat     = _c_p
    c_v::DFloat     = _c_v
    gravity::DFloat = _gravity
    Pr::DFloat = _Prandtl
    lambda::DFloat = _Stokes

    Np = (N+1)^dim
    Nfp = (N+1)^(dim-1)
    nface = 2*dim

    @inbounds for e in elems
        for f = 1:nface
            for n = 1:Nfp
                (nxM, nyM, nzM, sMJ, ~) = sgeo[:, n, f, e]
                idM, idP = vmapM[n, f, e], vmapP[n, f, e]

                eM, eP = e, ((idP - 1) ÷ Np) + 1
                vidM, vidP = ((idM - 1) % Np) + 1,  ((idP - 1) % Np) + 1

                #Left variables
                ρxM = gradQ[vidM, _ρ, 1, eM]
                ρyM = gradQ[vidM, _ρ, 2, eM]
                ρzM = gradQ[vidM, _ρ, 3, eM]
                UxM = gradQ[vidM, _U, 1, eM]
                UyM = gradQ[vidM, _U, 2, eM]
                UzM = gradQ[vidM, _U, 3, eM]
                VxM = gradQ[vidM, _V, 1, eM]
                VyM = gradQ[vidM, _V, 2, eM]
                VzM = gradQ[vidM, _V, 3, eM]
                WxM = gradQ[vidM, _W, 1, eM]
                WyM = gradQ[vidM, _W, 2, eM]
                WzM = gradQ[vidM, _W, 3, eM]
                ExM = gradQ[vidM, _E, 1, eM]
                EyM = gradQ[vidM, _E, 2, eM]
                EzM = gradQ[vidM, _E, 3, eM]
                ρM = Q[vidM, _ρ, eM]
                UM = Q[vidM, _U, eM]
                VM = Q[vidM, _V, eM]
                WM = Q[vidM, _W, eM]

                uM=UM/ρM
                vM=VM/ρM
                wM=WM/ρM
                uxM, uyM, uzM = UxM, UyM, UzM
                vxM, vyM, vzM = VxM, VyM, VzM
                wxM, wyM, wzM = WxM, WyM, WzM
                TxM, TyM, TzM = ExM, EyM, EzM

                #Right variables
                bc = elemtobndy[f, e]
                ρxP = ρyP = ρzP = zero(eltype(Q))
                UxP = UyP = UzP = zero(eltype(Q))
                VxP = VyP = VzP = zero(eltype(Q))
                WxP = WyP = WzP = zero(eltype(Q))
                ExP = EyP = EzP = zero(eltype(Q))
                if bc == 0
                    ρxP = gradQ[vidP, _ρ, 1, eP]
                    ρyP = gradQ[vidP, _ρ, 2, eP]
                    ρzP = gradQ[vidP, _ρ, 3, eP]
                    UxP = gradQ[vidP, _U, 1, eP]
                    UyP = gradQ[vidP, _U, 2, eP]
                    UzP = gradQ[vidP, _U, 3, eP]
                    VxP = gradQ[vidP, _V, 1, eP]
                    VyP = gradQ[vidP, _V, 2, eP]
                    VzP = gradQ[vidP, _V, 3, eP]
                    WxP = gradQ[vidP, _W, 1, eP]
                    WyP = gradQ[vidP, _W, 2, eP]
                    WzP = gradQ[vidP, _W, 3, eP]
                    ExP = gradQ[vidP, _E, 1, eP]
                    EyP = gradQ[vidP, _E, 2, eP]
                    EzP = gradQ[vidP, _E, 3, eP]
                    ρP = Q[vidP, _ρ, eP]
                    UP = Q[vidP, _U, eP]
                    VP = Q[vidP, _V, eP]
                    WP = Q[vidP, _W, eP]

                    uP=UP/ρP
                    vP=VP/ρP
                    wP=WP/ρP
                    uxP, uyP, uzP = UxP, UyP, UzP
                    vxP, vyP, vzP = VxP, VyP, VzP
                    wxP, wyP, wzP = WxP, WyP, WzP
                    TxP, TyP, TzP = ExP, EyP, EzP
                elseif bc == 1
                    ρnM = nxM * ρxM + nyM * ρyM + nzM * ρzM
                    ρxP = ρxM - 2 * ρnM * nxM
                    ρyP = ρyM - 2 * ρnM * nyM
                    ρzP = ρzM - 2 * ρnM * nzM
                    UnM = nxM * UxM + nyM * UyM + nzM * UzM
                    UxP = UxM - 2 * UnM * nxM
                    UyP = UyM - 2 * UnM * nyM
                    UzP = UzM - 2 * UnM * nzM
                    VnM = nxM * VxM + nyM * VyM + nzM * VzM
                    VxP = VxM - 2 * VnM * nxM
                    VyP = VyM - 2 * VnM * nyM
                    VzP = VzM - 2 * VnM * nzM
                    WnM = nxM * WxM + nyM * WyM + nzM * WzM
                    WxP = WxM - 2 * WnM * nxM
                    WyP = WyM - 2 * WnM * nyM
                    WzP = WzM - 2 * WnM * nzM
                    EnM = nxM * ExM + nyM * EyM + nzM * EzM
                    ExP = ExM - 2 * EnM * nxM
                    EyP = EyM - 2 * EnM * nyM
                    EzP = EzM - 2 * EnM * nzM

                    unM = nxM * uM + nyM * vM + nzM * wM
                    uP = uM - 2 * unM * nxM
                    vP = vM - 2 * unM * nyM
                    wP = wM - 2 * unM * nzM
                    uxP, uyP, uzP = UxP, UyP, UzP #FXG: Not sure about this BC
                    vxP, vyP, vzP = VxP, VyP, VzP #FXG: Not sure about this BC
                    wxP, wyP, wzP = WxP, WyP, WzP #FXG: Not sure about this BC
                    #TxP, TyP, TzP = ExP, EyP, EzP #Produces thermal boundary layer
                    TxP, TyP, TzP = TxM, TyM, TzM
                else
                    error(&quot;Invalid boundary conditions $bc on face $f of element $e&quot;)
                end

                #Left Fluxes
                div_uM=uxM + vyM + wzM
                fluxρM_x = 0*ρxM
                fluxρM_y = 0*ρyM
                fluxρM_z = 0*ρzM
                fluxUM_x = 2*uxM + lambda*div_uM
                fluxUM_y = uyM + vxM
                fluxUM_z = uzM + wxM
                fluxVM_x = vxM + uyM
                fluxVM_y = 2*vyM + lambda*div_uM
                fluxVM_z = vzM + wyM
                fluxWM_x = wxM + uzM
                fluxWM_y = wyM + vzM
                fluxWM_z = 2*wzM + lambda*div_uM
                fluxEM_x = uM*(2*uxM + lambda*div_uM) + vM*(uyM + vxM) + wM*(uzM + wxM) + c_p/Pr*TxM
                fluxEM_y = uM*(vxM + uyM) + vM*(2*vyM + lambda*div_uM) + wM*(vzM + wyM) + c_p/Pr*TyM
                fluxEM_z = uM*(wxM + uzM) + vM*(wyM + vzM) + wM*(2*wzM + lambda*div_uM) + c_p/Pr*TzM

                #Right Fluxes
                div_uP=uxP + vyP + wzP
                fluxρP_x = 0*ρxP
                fluxρP_y = 0*ρyP
                fluxρP_z = 0*ρzP
                fluxUP_x = 2*uxP + lambda*div_uP
                fluxUP_y = uyP + vxP
                fluxUP_z = uzP + wxP
                fluxVP_x = vxP + uyP
                fluxVP_y = 2*vyP + lambda*div_uP
                fluxVP_z = vzP + wyP
                fluxWP_x = wxP + uzP
                fluxWP_y = wyP + vzP
                fluxWP_z = 2*wzP + lambda*div_uP
                fluxEP_x = uP*(2*uxP + lambda*div_uP) + vP*(uyP + vxP) + wP*(uzP + wxP) + c_p/Pr*TxP
                fluxEP_y = uP*(vxP + uyP) + vP*(2*vyP + lambda*div_uP) + wP*(vzP + wyP) + c_p/Pr*TyP
                fluxEP_z = uP*(wxP + uzP) + vP*(wyP + vzP) + wP*(2*wzP + lambda*div_uP) + c_p/Pr*TzP

                #Compute Numerical Flux
                fluxρS = 0.5*(nxM * (fluxρM_x + fluxρP_x) + nyM * (fluxρM_y + fluxρP_y) + nzM * (fluxρM_z + fluxρP_z))
                fluxUS = 0.5*(nxM * (fluxUM_x + fluxUP_x) + nyM * (fluxUM_y + fluxUP_y) + nzM * (fluxUM_z + fluxUP_z))
                fluxVS = 0.5*(nxM * (fluxVM_x + fluxVP_x) + nyM * (fluxVM_y + fluxVP_y) + nzM * (fluxVM_z + fluxVP_z))
                fluxWS = 0.5*(nxM * (fluxWM_x + fluxWP_x) + nyM * (fluxWM_y + fluxWP_y) + nzM * (fluxWM_z + fluxWP_z))
                fluxES = 0.5*(nxM * (fluxEM_x + fluxEP_x) + nyM * (fluxEM_y + fluxEP_y) + nzM * (fluxEM_z + fluxEP_z))

                #Update RHS
                rhs[vidM, _ρ, 1, eM] += sMJ * fluxρS
                rhs[vidM, _U, 1, eM] += sMJ * fluxUS
                rhs[vidM, _V, 1, eM] += sMJ * fluxVS
                rhs[vidM, _W, 1, eM] += sMJ * fluxWS
                rhs[vidM, _E, 1, eM] += sMJ * fluxES
            end
        end
    end
end</code></pre><pre><code class="language-none">flux_div! (generic function with 1 method)</code></pre></div><p>}}}</p><p>{{{ Update grad Q solution</p><div><pre><code class="language-julia">function update_gradQ!(::Val{dim}, ::Val{N}, Q, rhs, vgeo, elems) where {dim, N}

    Nq=(N+1)^dim

    @inbounds for e = elems, s = 1:_nstate, i = 1:Nq
        Q[i, s, 1, e] = rhs[i, s, 1, e] * vgeo[i, _MJI, e]
        Q[i, s, 2, e] = rhs[i, s, 2, e] * vgeo[i, _MJI, e]
        Q[i, s, 3, e] = rhs[i, s, 3, e] * vgeo[i, _MJI, e]
    end

end</code></pre><pre><code class="language-none">update_gradQ! (generic function with 1 method)</code></pre></div><p>}}}</p><p>{{{ Update grad Q solution</p><div><pre><code class="language-julia">function update_divgradQ!(::Val{dim}, ::Val{N}, Q, rhs, vgeo, elems) where {dim, N}

    Nq=(N+1)^dim

    @inbounds for e = elems, s = 1:_nstate, i = 1:Nq
        Q[i, s, e] = rhs[i, s, 1, e] * vgeo[i, _MJI, e]
    end

end</code></pre><pre><code class="language-none">update_divgradQ! (generic function with 1 method)</code></pre></div><p>}}}</p><p>{{{ Update solution (for all dimensions)</p><div><pre><code class="language-julia">function updatesolution!(::Val{dim}, ::Val{N}, rhs::Array, rhs_gradQ, Q, vgeo, elems, rka,
                         rkb, dt, visc) where {dim, N}

    Nq=(N+1)^dim

    @inbounds for e = elems, s = 1:_nstate, i = 1:Nq
        rhs[i, s, e] += visc*rhs_gradQ[i,s,1,e]
        Q[i, s, e] += rkb * dt * rhs[i, s, e] * vgeo[i, _MJI, e]
        rhs[i, s, e] *= rka
    end
end</code></pre><pre><code class="language-none">updatesolution! (generic function with 1 method)</code></pre></div><p>}}} }}}</p><p>{{{ improved GPU kernles</p><p>{{{ Volume RHS for 3D</p><div><pre><code class="language-julia">@hascuda function knl_volume_rhs!(::Val{3}, ::Val{N}, rhs, Q, vgeo, D, nelem) where N
    DFloat = eltype(D)
    γ::DFloat       = _γ
    p0::DFloat      = _p0
    R_gas::DFloat   = _R_gas
    c_p::DFloat     = _c_p
    c_v::DFloat     = _c_v
    gravity::DFloat = _gravity

    Nq = N + 1

    (i, j, k) = threadIdx()
    e = blockIdx().x

    s_D = @cuStaticSharedMem(eltype(D), (Nq, Nq))
    s_F = @cuStaticSharedMem(eltype(Q), (Nq, Nq, Nq, _nstate))
    s_G = @cuStaticSharedMem(eltype(Q), (Nq, Nq, Nq, _nstate))
    s_H = @cuStaticSharedMem(eltype(Q), (Nq, Nq, Nq, _nstate))

    rhsU = rhsV = rhsW = rhsρ = rhsE = zero(eltype(rhs))
    @inbounds if i &lt;= Nq &amp;&amp; j &lt;= Nq &amp;&amp; k &lt;= Nq &amp;&amp; e &lt;= nelem</code></pre></div><p>Load derivative into shared memory</p><div><pre><code class="language-julia">        if k == 1
            s_D[i, j] = D[i, j]
        end</code></pre></div><p>Load values will need into registers</p><div><pre><code class="language-julia">        MJ = vgeo[i, j, k, _MJ, e]
        ξx, ξy, ξz = vgeo[i,j,k,_ξx,e], vgeo[i,j,k,_ξy,e], vgeo[i,j,k,_ξz,e]
        ηx, ηy, ηz = vgeo[i,j,k,_ηx,e], vgeo[i,j,k,_ηy,e], vgeo[i,j,k,_ηz,e]
        ζx, ζy, ζz = vgeo[i,j,k,_ζx,e], vgeo[i,j,k,_ζy,e], vgeo[i,j,k,_ζz,e]

        U, V, W = Q[i, j, k, _U, e], Q[i, j, k, _V, e], Q[i, j, k, _W, e]
        ρ, E = Q[i, j, k, _ρ, e], Q[i, j, k, _E, e]

        P = p0 * CUDAnative.pow(R_gas * E / p0, c_p / c_v)

        ρinv = 1 / ρ
        fluxρ_x = U
        fluxU_x = ρinv * U * U + P
        fluxV_x = ρinv * V * U
        fluxW_x = ρinv * W * U
        fluxE_x = E * ρinv * U

        fluxρ_y = V
        fluxU_y = ρinv * U * V
        fluxV_y = ρinv * V * V + P
        fluxW_y = ρinv * W * V
        fluxE_y = E * ρinv * V

        fluxρ_z = W
        fluxU_z = ρinv * U * W
        fluxV_z = ρinv * V * W
        fluxW_z = ρinv * W * W + P
        fluxE_z = E * ρinv * W

        s_F[i, j, k, _ρ] = MJ * (ξx * fluxρ_x + ξy * fluxρ_y + ξz * fluxρ_z)
        s_F[i, j, k, _U] = MJ * (ξx * fluxU_x + ξy * fluxU_y + ξz * fluxU_z)
        s_F[i, j, k, _V] = MJ * (ξx * fluxV_x + ξy * fluxV_y + ξz * fluxV_z)
        s_F[i, j, k, _W] = MJ * (ξx * fluxW_x + ξy * fluxW_y + ξz * fluxW_z)
        s_F[i, j, k, _E] = MJ * (ξx * fluxE_x + ξy * fluxE_y + ξz * fluxE_z)

        s_G[i, j, k, _ρ] = MJ * (ηx * fluxρ_x + ηy * fluxρ_y + ηz * fluxρ_z)
        s_G[i, j, k, _U] = MJ * (ηx * fluxU_x + ηy * fluxU_y + ηz * fluxU_z)
        s_G[i, j, k, _V] = MJ * (ηx * fluxV_x + ηy * fluxV_y + ηz * fluxV_z)
        s_G[i, j, k, _W] = MJ * (ηx * fluxW_x + ηy * fluxW_y + ηz * fluxW_z)
        s_G[i, j, k, _E] = MJ * (ηx * fluxE_x + ηy * fluxE_y + ηz * fluxE_z)

        s_H[i, j, k, _ρ] = MJ * (ζx * fluxρ_x + ζy * fluxρ_y + ζz * fluxρ_z)
        s_H[i, j, k, _U] = MJ * (ζx * fluxU_x + ζy * fluxU_y + ζz * fluxU_z)
        s_H[i, j, k, _V] = MJ * (ζx * fluxV_x + ζy * fluxV_y + ζz * fluxV_z)
        s_H[i, j, k, _W] = MJ * (ζx * fluxW_x + ζy * fluxW_y + ζz * fluxW_z)
        s_H[i, j, k, _E] = MJ * (ζx * fluxE_x + ζy * fluxE_y + ζz * fluxE_z)

        rhsU, rhsV, rhsW = (rhs[i, j, k, _U, e],
                            rhs[i, j, k, _V, e],
                            rhs[i, j, k, _W, e])
        rhsρ, rhsE = rhs[i, j, k, _ρ, e], rhs[i, j, k, _E, e]</code></pre></div><p>buoyancy term</p><div><pre><code class="language-julia">        rhsW -= MJ * ρ * gravity
    end

    sync_threads()

    @inbounds if i &lt;= Nq &amp;&amp; j &lt;= Nq &amp;&amp; k &lt;= Nq &amp;&amp; e &lt;= nelem</code></pre></div><p>loop of ξ-grid lines</p><div><pre><code class="language-julia">        for n = 1:Nq
            Dni = s_D[n, i]
            Dnj = s_D[n, j]
            Dnk = s_D[n, k]

            rhsρ += Dni * s_F[n, j, k, _ρ]
            rhsρ += Dnj * s_G[i, n, k, _ρ]
            rhsρ += Dnk * s_H[i, j, n, _ρ]

            rhsU += Dni * s_F[n, j, k, _U]
            rhsU += Dnj * s_G[i, n, k, _U]
            rhsU += Dnk * s_H[i, j, n, _U]

            rhsV += Dni * s_F[n, j, k, _V]
            rhsV += Dnj * s_G[i, n, k, _V]
            rhsV += Dnk * s_H[i, j, n, _V]

            rhsW += Dni * s_F[n, j, k, _W]
            rhsW += Dnj * s_G[i, n, k, _W]
            rhsW += Dnk * s_H[i, j, n, _W]

            rhsE += Dni * s_F[n, j, k, _E]
            rhsE += Dnj * s_G[i, n, k, _E]
            rhsE += Dnk * s_H[i, j, n, _E]
        end

        rhs[i, j, k, _U, e] = rhsU
        rhs[i, j, k, _V, e] = rhsV
        rhs[i, j, k, _W, e] = rhsW
        rhs[i, j, k, _ρ, e] = rhsρ
        rhs[i, j, k, _E, e] = rhsE
    end
    nothing
end</code></pre><pre><code class="language-none">()</code></pre></div><p>}}}</p><p>{{{ Face RHS (all dimensions)</p><div><pre><code class="language-julia">@hascuda function knl_flux_rhs!(::Val{dim}, ::Val{N}, rhs, Q, sgeo, vgeo, nelem, vmapM,
                               vmapP, elemtobndy) where {dim, N}
    DFloat = eltype(Q)
    γ::DFloat       = _γ
    p0::DFloat      = _p0
    R_gas::DFloat   = _R_gas
    c_p::DFloat     = _c_p
    c_v::DFloat     = _c_v
    gravity::DFloat = _gravity

    Np = (N+1) * (N+1) * (N+1)
    nface = 6

    (i, j, k) = threadIdx()
    e = blockIdx().x

    Nq = N+1
    half = convert(eltype(Q), 0.5)

    @inbounds if i &lt;= Nq &amp;&amp; j &lt;= Nq &amp;&amp; k == 1 &amp;&amp; e &lt;= nelem
        n = i + (j-1) * Nq
        for lf = 1:2:nface
            for f = lf:lf+1
                (nxM, nyM) = (sgeo[_nx, n, f, e], sgeo[_ny, n, f, e])
                (nzM, sMJ) = (sgeo[_nz, n, f, e], sgeo[_sMJ, n, f, e])

                (idM, idP) = (vmapM[n, f, e], vmapP[n, f, e])

                (eM, eP) = (e, ((idP - 1) ÷ Np) + 1)
                (vidM, vidP) = (((idM - 1) % Np) + 1,  ((idP - 1) % Np) + 1)

                ρM = Q[vidM, _ρ, eM]
                UM = Q[vidM, _U, eM]
                VM = Q[vidM, _V, eM]
                WM = Q[vidM, _W, eM]
                EM = Q[vidM, _E, eM]

                bc = elemtobndy[f, e]
                PM = p0 * CUDAnative.pow(R_gas * EM / p0, c_p / c_v)
                ρP = UP = VP = WP = EP = PP = zero(eltype(Q))
                if bc == 0
                    ρP = Q[vidP, _ρ, eP]
                    UP = Q[vidP, _U, eP]
                    VP = Q[vidP, _V, eP]
                    WP = Q[vidP, _W, eP]
                    EP = Q[vidP, _E, eP]
                    PP = p0 * CUDAnative.pow(R_gas * EP / p0, c_p / c_v)
                elseif bc == 1
                    UnM = nxM * UM + nyM * VM + nzM * WM
                    UP = UM - 2 * UnM * nxM
                    VP = VM - 2 * UnM * nyM
                    WP = WM - 2 * UnM * nzM
                    ρP = ρM
                    EP = EM
                    PP = PM
                end

                ρMinv = 1 / ρM
                fluxρM_x = UM
                fluxUM_x = ρMinv * UM * UM + PM
                fluxVM_x = ρMinv * VM * UM
                fluxWM_x = ρMinv * WM * UM
                fluxEM_x = ρMinv * UM * EM

                fluxρM_y = VM
                fluxUM_y = ρMinv * UM * VM
                fluxVM_y = ρMinv * VM * VM + PM
                fluxWM_y = ρMinv * WM * VM
                fluxEM_y = ρMinv * VM * EM

                fluxρM_z = WM
                fluxUM_z = ρMinv * UM * WM
                fluxVM_z = ρMinv * VM * WM
                fluxWM_z = ρMinv * WM * WM + PM
                fluxEM_z = ρMinv * WM * EM

                ρPinv = 1 / ρP
                fluxρP_x = UP
                fluxUP_x = ρPinv * UP * UP + PP
                fluxVP_x = ρPinv * VP * UP
                fluxWP_x = ρPinv * WP * UP
                fluxEP_x = ρPinv * UP * EP

                fluxρP_y = VP
                fluxUP_y = ρPinv * UP * VP
                fluxVP_y = ρPinv * VP * VP + PP
                fluxWP_y = ρPinv * WP * VP
                fluxEP_y = ρPinv * VP * EP

                fluxρP_z = WP
                fluxUP_z = ρPinv * UP * WP
                fluxVP_z = ρPinv * VP * WP
                fluxWP_z = ρPinv * WP * WP + PP
                fluxEP_z = ρPinv * WP * EP

                λM = ρMinv * abs(nxM * UM + nyM * VM + nzM * WM) + CUDAnative.sqrt(ρMinv * γ * PM)
                λP = ρPinv * abs(nxM * UP + nyM * VP + nzM * WP) + CUDAnative.sqrt(ρPinv * γ * PP)
                λ  =  max(λM, λP)

                #Compute Numerical Flux and Update
                fluxρS = (nxM * (fluxρM_x + fluxρP_x) + nyM * (fluxρM_y + fluxρP_y) +
                          nzM * (fluxρM_z + fluxρP_z) - λ * (ρP - ρM)) / 2
                fluxUS = (nxM * (fluxUM_x + fluxUP_x) + nyM * (fluxUM_y + fluxUP_y) +
                          nzM * (fluxUM_z + fluxUP_z) - λ * (UP - UM)) / 2
                fluxVS = (nxM * (fluxVM_x + fluxVP_x) + nyM * (fluxVM_y + fluxVP_y) +
                          nzM * (fluxVM_z + fluxVP_z) - λ * (VP - VM)) / 2
                fluxWS = (nxM * (fluxWM_x + fluxWP_x) + nyM * (fluxWM_y + fluxWP_y) +
                          nzM * (fluxWM_z + fluxWP_z) - λ * (WP - WM)) / 2
                fluxES = (nxM * (fluxEM_x + fluxEP_x) + nyM * (fluxEM_y + fluxEP_y) +
                          nzM * (fluxEM_z + fluxEP_z) - λ * (EP - EM)) / 2

                #Update RHS
                rhs[vidM, _ρ, eM] -= sMJ * fluxρS
                rhs[vidM, _U, eM] -= sMJ * fluxUS
                rhs[vidM, _V, eM] -= sMJ * fluxVS
                rhs[vidM, _W, eM] -= sMJ * fluxWS
                rhs[vidM, _E, eM] -= sMJ * fluxES
            end
            sync_threads()
        end
    end
nothing
end</code></pre><pre><code class="language-none">()</code></pre></div><p>}}}</p><p>{{{ Update solution (for all dimensions)</p><div><pre><code class="language-julia">@hascuda function knl_updatesolution!(::Val{dim}, ::Val{N}, rhs, Q, vgeo, nelem, rka,
                                      rkb, dt) where {dim, N}
    (i, j, k) = threadIdx()
    e = blockIdx().x

    Nq = N+1
    @inbounds if i &lt;= Nq &amp;&amp; j &lt;= Nq &amp;&amp; k &lt;= Nq &amp;&amp; e &lt;= nelem
        n = i + (j-1) * Nq + (k-1) * Nq * Nq
        MJI = vgeo[n, _MJI, e]
        for s = 1:_nstate
            Q[n, s, e] += rkb * dt * rhs[n, s, e] * MJI
            rhs[n, s, e] *= rka
        end
    end
    nothing
end</code></pre><pre><code class="language-none">()</code></pre></div><p>}}}</p><p>}}}</p><p>{{{ Fill sendQ on device with Q (for all dimensions)</p><div><pre><code class="language-julia">@hascuda function knl_fillsendQ!(::Val{dim}, ::Val{N}, sendQ, Q,
                                 sendelems) where {N, dim}
    Nq = N + 1
    (i, j, k) = threadIdx()
    e = blockIdx().x

    @inbounds if i &lt;= Nq &amp;&amp; j &lt;= Nq &amp;&amp; k &lt;= Nq &amp;&amp; e &lt;= length(sendelems)
        n = i + (j-1) * Nq + (k-1) * Nq * Nq
        re = sendelems[e]
        for s = 1:_nstate
            sendQ[n, s, e] = Q[n, s, re]
        end
    end
    nothing
end</code></pre><pre><code class="language-none">()</code></pre></div><p>}}}</p><p>{{{ Fill Q on device with recvQ (for all dimensions)</p><div><pre><code class="language-julia">@hascuda function knl_transferrecvQ!(::Val{dim}, ::Val{N}, Q, recvQ, nelem,
                                     nrealelem) where {N, dim}
    Nq = N + 1
    (i, j, k) = threadIdx()
    e = blockIdx().x

    @inbounds if i &lt;= Nq &amp;&amp; j &lt;= Nq &amp;&amp; k &lt;= Nq &amp;&amp; e &lt;= nelem
        n = i + (j-1) * Nq + (k-1) * Nq * Nq
        for s = 1:_nstate
            Q[n, s, nrealelem + e] = recvQ[n, s, e]
        end
    end
    nothing
end</code></pre><pre><code class="language-none">()</code></pre></div><p>}}}</p><p>{{{ MPI Buffer handling</p><div><pre><code class="language-julia">function fillsendQ!(::Val{dim}, ::Val{N}, sendQ, d_sendQ::Array, Q,
                    sendelems) where {dim, N}
    sendQ[:, :, :] .= Q[:, :, sendelems]
end

@hascuda function fillsendQ!(::Val{dim}, ::Val{N}, sendQ, d_sendQ::CuArray,
                             d_QL, d_sendelems) where {dim, N}
    nsendelem = length(d_sendelems)
    if nsendelem &gt; 0
        @cuda(threads=ntuple(j-&gt;N+1, dim), blocks=nsendelem,
              knl_fillsendQ!(Val(dim), Val(N), d_sendQ, d_QL, d_sendelems))
        sendQ .= d_sendQ
    end
end

@hascuda function transferrecvQ!(::Val{dim}, ::Val{N}, d_recvQ::CuArray, recvQ,
                                 d_QL, nrealelem) where {dim, N}
    nrecvelem = size(recvQ)[end]
    if nrecvelem &gt; 0
        d_recvQ .= recvQ
        @cuda(threads=ntuple(j-&gt;N+1, dim), blocks=nrecvelem,
              knl_transferrecvQ!(Val(dim), Val(N), d_QL, d_recvQ, nrecvelem,
                                 nrealelem))
    end
end

function transferrecvQ!(::Val{dim}, ::Val{N}, d_recvQ::Array, recvQ, Q,
                        nrealelem) where {dim, N}
    Q[:, :, nrealelem+1:end] .= recvQ[:, :, :]
end</code></pre><pre><code class="language-none">transferrecvQ! (generic function with 1 method)</code></pre></div><p>}}}</p><p>{{{ GPU kernel wrappers</p><div><pre><code class="language-julia">@hascuda function volume_rhs!(::Val{dim}, ::Val{N}, d_rhsC::CuArray, d_QC,
                             d_vgeoC, d_D, elems) where {dim, N}
    nelem = length(elems)
    @cuda(threads=ntuple(j-&gt;N+1, dim), blocks=nelem,
          knl_volume_rhs!(Val(dim), Val(N), d_rhsC, d_QC, d_vgeoC, d_D, nelem))
end

@hascuda function flux_rhs!(::Val{dim}, ::Val{N}, d_rhsL::CuArray, d_QL, d_sgeo,
                           d_vgeoL, elems, d_vmapM, d_vmapP, d_elemtobndy) where {dim, N}
    nelem = length(elems)
    @cuda(threads=(ntuple(j-&gt;N+1, dim-1)..., 1), blocks=nelem,
          knl_flux_rhs!(Val(dim), Val(N), d_rhsL, d_QL, d_sgeo, d_vgeoL, nelem, d_vmapM,
                       d_vmapP, d_elemtobndy))
end

@hascuda function updatesolution!(::Val{dim}, ::Val{N}, d_rhsL::CuArray, d_QL,
                                  d_vgeoL, elems, rka, rkb, dt) where {dim, N}
    nelem = length(elems)
    @cuda(threads=ntuple(j-&gt;N+1, dim), blocks=nelem,
          knl_updatesolution!(Val(dim), Val(N), d_rhsL, d_QL, d_vgeoL, nelem, rka,
                              rkb, dt))
end</code></pre><pre><code class="language-none">()</code></pre></div><p>}}}</p><p>{{{ L2 Energy (for all dimensions)</p><div><pre><code class="language-julia">function L2energysquared(::Val{dim}, ::Val{N}, Q, vgeo, elems) where {dim, N}
    DFloat = eltype(Q)
    Np = (N+1)^dim
    (~, nstate, nelem) = size(Q)

    energy = zero(DFloat)

    @inbounds for e = elems, q = 1:nstate, i = 1:Np
        energy += vgeo[i, _MJ, e] * Q[i, q, e]^2
    end

    energy
end</code></pre><pre><code class="language-none">L2energysquared (generic function with 1 method)</code></pre></div><p>}}}</p><p>{{{ Send Data Q</p><div><pre><code class="language-julia">function senddata_Q(::Val{dim}, ::Val{N}, mesh, sendreq, recvreq, sendQ,
                  recvQ, d_sendelems, d_sendQ, d_recvQ, d_QL, mpicomm;
                  ArrType=ArrType) where {dim, N}
    mpirank = MPI.Comm_rank(mpicomm)</code></pre></div><p>Create send and recv request array</p><div><pre><code class="language-julia">    nnabr = length(mesh.nabrtorank)
    d_sendelems = ArrType(mesh.sendelems)
    nrealelem = length(mesh.realelems)</code></pre></div><p>post MPI receives</p><div><pre><code class="language-julia">    for n = 1:nnabr
        recvreq[n] = MPI.Irecv!((@view recvQ[:, :, mesh.nabrtorecv[n]]),
                                mesh.nabrtorank[n], 777, mpicomm)
    end</code></pre></div><p>wait on (prior) MPI sends</p><div><pre><code class="language-julia">    MPI.Waitall!(sendreq)</code></pre></div><p>pack data from d<em>QL into send buffer    fillsendQ!(Val(dim), Val(N), sendQ, d</em>sendQ, d<em>QL, d</em>sendelems)</p><div><pre><code class="language-julia">    sendQ[:, :, :] .= d_QL[:, :, d_sendelems]</code></pre></div><p>post MPI sends</p><div><pre><code class="language-julia">    for n = 1:nnabr
        sendreq[n] = MPI.Isend((@view sendQ[:, :, mesh.nabrtosend[n]]),
                               mesh.nabrtorank[n], 777, mpicomm)
    end
end</code></pre><pre><code class="language-none">senddata_Q (generic function with 1 method)</code></pre></div><p>}}}</p><p>{{{ Send Data Grad(Q)</p><div><pre><code class="language-julia">function senddata_gradQ(::Val{dim}, ::Val{N}, mesh, sendreq, recvreq, sendQ,
                  recvQ, d_sendelems, d_sendQ, d_recvQ, d_QL, mpicomm;
                  ArrType=ArrType) where {dim, N}
    mpirank = MPI.Comm_rank(mpicomm)</code></pre></div><p>Create send and recv request array</p><div><pre><code class="language-julia">    nnabr = length(mesh.nabrtorank)
    d_sendelems = ArrType(mesh.sendelems)
    nrealelem = length(mesh.realelems)</code></pre></div><p>post MPI receives</p><div><pre><code class="language-julia">    for n = 1:nnabr
        recvreq[n] = MPI.Irecv!((@view recvQ[:, :, :, mesh.nabrtorecv[n]]),
                                mesh.nabrtorank[n], 777, mpicomm)
    end</code></pre></div><p>wait on (prior) MPI sends</p><div><pre><code class="language-julia">    MPI.Waitall!(sendreq)</code></pre></div><p>pack data from d<em>QL into send buffer    fillsendQ!(Val(dim), Val(N), sendQ, d</em>sendQ, d<em>QL, d</em>sendelems)</p><div><pre><code class="language-julia">    sendQ[:, :, :, :] .= d_QL[:, :, :, d_sendelems]</code></pre></div><p>post MPI sends</p><div><pre><code class="language-julia">    for n = 1:nnabr
        sendreq[n] = MPI.Isend((@view sendQ[:, :, :, mesh.nabrtosend[n]]),
                               mesh.nabrtorank[n], 777, mpicomm)
    end
end</code></pre><pre><code class="language-none">senddata_gradQ (generic function with 1 method)</code></pre></div><p>}}}</p><p>{{{ Receive Data Q</p><div><pre><code class="language-julia">function receivedata_Q!(::Val{dim}, ::Val{N}, mesh, recvreq, recvQ,
                        d_recvQ, d_QL) where {dim, N}
    nrealelem = length(mesh.realelems)</code></pre></div><p>wait on MPI receives</p><div><pre><code class="language-julia">    MPI.Waitall!(recvreq)</code></pre></div><p>copy data to state vector d_QL</p><div><pre><code class="language-julia">    #transferrecvQ!(Val(dim), Val(N), d_recvQ, recvQ, d_QL, nrealelem)
    d_QL[:, :, nrealelem+1:end] .= recvQ[:, :, :]

end</code></pre><pre><code class="language-none">receivedata_Q! (generic function with 1 method)</code></pre></div><p>}}}</p><p>{{{ Receive Data Grad(Q)</p><div><pre><code class="language-julia">function receivedata_gradQ!(::Val{dim}, ::Val{N}, mesh, recvreq, recvQ,
                            d_recvQ, d_QL) where {dim, N}
    nrealelem = length(mesh.realelems)</code></pre></div><p>wait on MPI receives</p><div><pre><code class="language-julia">    MPI.Waitall!(recvreq)</code></pre></div><p>copy data to state vector d_QL</p><div><pre><code class="language-julia">    #transferrecvQ!(Val(dim), Val(N), d_recvQ, recvQ, d_QL, nrealelem)
    d_QL[:, :, :, nrealelem+1:end] .= recvQ[:, :, :, :]
end</code></pre><pre><code class="language-none">receivedata_gradQ! (generic function with 1 method)</code></pre></div><p>}}}</p><p>{{{ RK loop</p><div><pre><code class="language-julia">function lowstorageRK(::Val{dim}, ::Val{N}, mesh, vgeo, sgeo, Q, rhs, D,
                      dt, nsteps, tout, vmapM, vmapP, mpicomm, iplot, visc;
                      ArrType=ArrType, plotstep=0) where {dim, N}
    DFloat = eltype(Q)
    mpirank = MPI.Comm_rank(mpicomm)</code></pre></div><p>Fourth-order, low-storage, Runge–Kutta scheme of Carpenter and Kennedy (1994) ((5,4) 2N-Storage RK scheme.</p><p>Ref: @TECHREPORT{CarpenterKennedy1994,   author = {M.~H. Carpenter and C.~A. Kennedy},   title = {Fourth-order {2N-storage} {Runge-Kutta} schemes},   institution = {National Aeronautics and Space Administration},   year = {1994},   number = {NASA TM-109112},   address = {Langley Research Center, Hampton, VA}, }</p><div><pre><code class="language-julia">    RKA = (DFloat(0),
           DFloat(-567301805773)  / DFloat(1357537059087),
           DFloat(-2404267990393) / DFloat(2016746695238),
           DFloat(-3550918686646) / DFloat(2091501179385),
           DFloat(-1275806237668) / DFloat(842570457699 ))

    RKB = (DFloat(1432997174477) / DFloat(9575080441755 ),
           DFloat(5161836677717) / DFloat(13612068292357),
           DFloat(1720146321549) / DFloat(2090206949498 ),
           DFloat(3134564353537) / DFloat(4481467310338 ),
           DFloat(2277821191437) / DFloat(14882151754819))

    RKC = (DFloat(0),
           DFloat(1432997174477) / DFloat(9575080441755),
           DFloat(2526269341429) / DFloat(6820363962896),
           DFloat(2006345519317) / DFloat(3224310063776),
           DFloat(2802321613138) / DFloat(2924317926251))</code></pre></div><p>Create send and recv request array</p><div><pre><code class="language-julia">    nnabr = length(mesh.nabrtorank)
    sendreq = fill(MPI.REQUEST_NULL, nnabr)
    recvreq = fill(MPI.REQUEST_NULL, nnabr)</code></pre></div><p>Create send and recv buffer</p><div><pre><code class="language-julia">    sendQ = zeros(DFloat, (N+1)^dim, size(Q,2), length(mesh.sendelems))
    recvQ = zeros(DFloat, (N+1)^dim, size(Q,2), length(mesh.ghostelems))</code></pre></div><p>Create send and recv LDG buffer</p><div><pre><code class="language-julia">    sendgradQ = zeros(DFloat, (N+1)^dim, size(Q,2), dim, length(mesh.sendelems))
    recvgradQ = zeros(DFloat, (N+1)^dim, size(Q,2), dim, length(mesh.ghostelems))</code></pre></div><p>Store Constants</p><div><pre><code class="language-julia">    nrealelem = length(mesh.realelems)
    nsendelem = length(mesh.sendelems)
    nrecvelem = length(mesh.ghostelems)
    nelem = length(mesh.elems)

    #Create Device Arrays
    d_QL, d_rhsL = ArrType(Q), ArrType(rhs)
    d_vgeoL, d_sgeo = ArrType(vgeo), ArrType(sgeo)
    d_vmapM, d_vmapP = ArrType(vmapM), ArrType(vmapP)
    d_sendelems, d_elemtobndy = ArrType(mesh.sendelems), ArrType(mesh.elemtobndy)
    d_sendQ, d_recvQ = ArrType(sendQ), ArrType(recvQ)
    d_D = ArrType(D)
    #Create Device LDG Arrays
    d_gradQL = zeros(DFloat, (N+1)^dim, _nstate, dim, nelem)
    d_rhs_gradQL = zeros(DFloat, (N+1)^dim, _nstate, dim, nelem)
    d_sendgradQ, d_recvgradQ = ArrType(sendgradQ), ArrType(recvgradQ)

    #Template Reshape Arrays
    Qshape    = (fill(N+1, dim)..., size(Q, 2), size(Q, 3))
    vgeoshape = (fill(N+1, dim)..., _nvgeo, size(Q, 3))
    gradQshape = (fill(N+1, dim)..., size(d_gradQL,2), size(d_gradQL,3), size(d_gradQL,4))

    #Reshape Device Arrays
    d_QC = reshape(d_QL, Qshape)
    d_rhsC = reshape(d_rhsL, Qshape...)
    d_vgeoC = reshape(d_vgeoL, vgeoshape)
    #Reshape Device LDG Arrays
    d_gradQC = reshape(d_gradQL, gradQshape)
    d_rhs_gradQC = reshape(d_rhs_gradQL, gradQshape...)

    start_time = t1 = time_ns()
    for step = 1:nsteps
        for s = 1:length(RKA)</code></pre></div><p>Send Data Q</p><div><pre><code class="language-julia">            senddata_Q(Val(dim), Val(N), mesh, sendreq, recvreq, sendQ,
                       recvQ, d_sendelems, d_sendQ, d_recvQ, d_QL, mpicomm;
                       ArrType=ArrType)</code></pre></div><p>volume RHS computation</p><div><pre><code class="language-julia">            volume_rhs!(Val(dim), Val(N), d_rhsC, d_QC, d_vgeoC, d_D, mesh.realelems)</code></pre></div><p>Receive Data Q</p><div><pre><code class="language-julia">            receivedata_Q!(Val(dim), Val(N), mesh, recvreq, recvQ, d_recvQ, d_QL)</code></pre></div><p>face RHS computation</p><div><pre><code class="language-julia">            flux_rhs!(Val(dim), Val(N), d_rhsL, d_QL, d_sgeo, d_vgeoL, mesh.realelems, d_vmapM,
                     d_vmapP, d_elemtobndy)</code></pre></div><div><pre><code class="language-julia">            if (visc &gt; 0)</code></pre></div><p>volume grad Q computation</p><div><pre><code class="language-julia">                volume_grad!(Val(dim), Val(N), d_rhs_gradQC, d_QC, d_vgeoC, d_D, mesh.realelems)</code></pre></div><p>flux grad Q computation</p><div><pre><code class="language-julia">                flux_grad!(Val(dim), Val(N), d_rhs_gradQL, d_QL, d_sgeo, d_vgeoL, mesh.realelems, d_vmapM, d_vmapP, d_elemtobndy)</code></pre></div><p>Construct grad Q</p><div><pre><code class="language-julia">                update_gradQ!(Val(dim), Val(N), d_gradQL, d_rhs_gradQL, d_vgeoL, mesh.realelems)</code></pre></div><p>Send Data grad(Q)</p><div><pre><code class="language-julia">                senddata_gradQ(Val(dim), Val(N), mesh, sendreq, recvreq, sendgradQ,
                               recvgradQ, d_sendelems, d_sendgradQ, d_recvgradQ,
                               d_gradQL, mpicomm;ArrType=ArrType)</code></pre></div><p>volume div(grad Q) computation</p><div><pre><code class="language-julia">                volume_div!(Val(dim), Val(N), d_rhs_gradQC, d_gradQC, d_QC, d_vgeoC, d_D, mesh.realelems)</code></pre></div><p>Receive Data grad(Q)</p><div><pre><code class="language-julia">                receivedata_gradQ!(Val(dim), Val(N), mesh, recvreq, recvgradQ, d_recvgradQ, d_gradQL)</code></pre></div><p>flux div(grad Q) computation</p><div><pre><code class="language-julia">                flux_div!(Val(dim), Val(N), d_rhs_gradQL, d_gradQL, d_QL, d_sgeo, mesh.realelems, d_vmapM, d_vmapP, d_elemtobndy)
            end</code></pre></div><p>update solution and scale RHS</p><div><pre><code class="language-julia">            updatesolution!(Val(dim), Val(N), d_rhsL, d_rhs_gradQL, d_QL, d_vgeoL, mesh.realelems,
                            RKA[s%length(RKA)+1], RKB[s], dt, visc)
        end
        if step == 1
            @hascuda synchronize()
            start_time = time_ns()
        end
        if mpirank == 0 &amp;&amp; (time_ns() - t1)*1e-9 &gt; tout
            @hascuda synchronize()
            t1 = time_ns()
            avg_stage_time = (time_ns() - start_time) * 1e-9 / ((step-1) * length(RKA))
            @show (step, nsteps, avg_stage_time)
        end</code></pre></div><p>Write VTK file</p><div><pre><code class="language-julia">        if mod(step,iplot) == 0
            Q .= d_QL
            convert_set3c_to_set2nc(Val(dim), Val(N), vgeo, Q)
            X = ntuple(j-&gt;reshape((@view vgeo[:, _x+j-1, :]), ntuple(j-&gt;N+1,dim)..., nelem), dim)
            ρ = reshape((@view Q[:, _ρ, :]), ntuple(j-&gt;(N+1),dim)..., nelem)
            U = reshape((@view Q[:, _U, :]), ntuple(j-&gt;(N+1),dim)..., nelem)
            V = reshape((@view Q[:, _V, :]), ntuple(j-&gt;(N+1),dim)..., nelem)
            W = reshape((@view Q[:, _W, :]), ntuple(j-&gt;(N+1),dim)..., nelem)
            E = reshape((@view Q[:, _E, :]), ntuple(j-&gt;(N+1),dim)..., nelem)
            E = E .- 300.0
            writemesh(@sprintf(&quot;viz/nse%dD_set3c_%s_rank_%04d_step_%05d&quot;,dim, ArrType, mpirank, step), X...;
                      fields=((&quot;ρ&quot;, ρ), (&quot;U&quot;, U), (&quot;V&quot;, V), (&quot;W&quot;, W), (&quot;E&quot;, E)), realelems=mesh.realelems)
        end
    end
if mpirank == 0
    avg_stage_time = (time_ns() - start_time) * 1e-9 / ((nsteps-1) * length(RKA))
    @show (nsteps, avg_stage_time)
end
Q .= d_QL
rhs .= d_rhsL
end</code></pre><pre><code class="language-none">lowstorageRK (generic function with 1 method)</code></pre></div><p>}}}</p><p>{{{ convert_variables</p><div><pre><code class="language-julia">function convert_set2nc_to_set2c(::Val{dim}, ::Val{N}, vgeo, Q) where {dim, N}
    DFloat = eltype(Q)
    γ::DFloat       = _γ
    p0::DFloat      = _p0
    R_gas::DFloat   = _R_gas
    c_p::DFloat     = _c_p
    c_v::DFloat     = _c_v
    gravity::DFloat = _gravity

    Np = (N+1)^dim
    (~, ~, nelem) = size(Q)

    println(&quot;[CPU] converting variables (CPU)...&quot;)
    @inbounds for e = 1:nelem, n = 1:Np
        ρ, u, v, w, E = Q[n, _ρ, e], Q[n, _U, e], Q[n, _V, e], Q[n, _W, e], Q[n, _E, e]
        Q[n, _U, e] = ρ*u
        Q[n, _V, e] = ρ*v
        Q[n, _W, e] = ρ*w
        Q[n, _E, e] = ρ*E
    end
end</code></pre><pre><code class="language-none">convert_set2nc_to_set2c (generic function with 1 method)</code></pre></div><p>}}}</p><div><pre><code class="language-julia">function convert_set2c_to_set2nc(::Val{dim}, ::Val{N}, vgeo, Q) where {dim, N}
    DFloat = eltype(Q)
    γ::DFloat       = _γ
    p0::DFloat      = _p0
    R_gas::DFloat   = _R_gas
    c_p::DFloat     = _c_p
    c_v::DFloat     = _c_v
    gravity::DFloat = _gravity

    Np = (N+1)^dim
    (~, ~, nelem) = size(Q)

    @inbounds for e = 1:nelem, n = 1:Np
        ρ, U, V, W, E = Q[n, _ρ, e], Q[n, _U, e], Q[n, _V, e], Q[n, _W, e], Q[n, _E, e]
        u=U/ρ
        v=V/ρ
        w=W/ρ
        E=E/ρ
        Q[n, _U, e] = u
        Q[n, _V, e] = v
        Q[n, _W, e] = w
        Q[n, _E, e] = E
    end
end

function convert_set2nc_to_set3c(::Val{dim}, ::Val{N}, vgeo, Q) where {dim, N}
    DFloat = eltype(Q)
    γ::DFloat       = _γ
    p0::DFloat      = _p0
    R_gas::DFloat   = _R_gas
    c_p::DFloat     = _c_p
    c_v::DFloat     = _c_v
    gravity::DFloat = _gravity

    Np = (N+1)^dim
    (~, ~, nelem) = size(Q)

    @inbounds for e = 1:nelem, n = 1:Np
        ρ, u, v, w, E = Q[n, _ρ, e], Q[n, _U, e], Q[n, _V, e], Q[n, _W, e], Q[n, _E, e]
        z = vgeo[n, _z, e]
        P = p0 * (ρ * R_gas * E / p0)^(c_p / c_v)
        T = P/(ρ*R_gas)
        E = c_v*T + 0.5*(u^2 + v^2 + w^2) + gravity*z
        Q[n, _U, e] = ρ*u
        Q[n, _V, e] = ρ*v
        Q[n, _W, e] = ρ*w
        Q[n, _E, e] = ρ*E
    end
end

function convert_set3c_to_set2nc(::Val{dim}, ::Val{N}, vgeo, Q) where {dim, N}
    DFloat = eltype(Q)
    γ::DFloat       = _γ
    p0::DFloat      = _p0
    R_gas::DFloat   = _R_gas
    c_p::DFloat     = _c_p
    c_v::DFloat     = _c_v
    gravity::DFloat = _gravity

    Np = (N+1)^dim
    (~, ~, nelem) = size(Q)

    @inbounds for e = 1:nelem, n = 1:Np
        ρ, U, V, W, E = Q[n, _ρ, e], Q[n, _U, e], Q[n, _V, e], Q[n, _W, e], Q[n, _E, e]
        z = vgeo[n, _z, e]
        u=U/ρ
        v=V/ρ
        w=W/ρ
        E=E/ρ
        P = (R_gas/c_v)*ρ*(E - 0.5*(u^2 + v^2 + w^2) - gravity*z)
        E=p0/(ρ * R_gas)*( P/p0 )^(c_v/c_p)
        Q[n, _U, e] = u
        Q[n, _V, e] = v
        Q[n, _W, e] = w
        Q[n, _E, e] = E
    end
end

function convert_set2nc_to_set4c(::Val{dim}, ::Val{N}, vgeo, Q) where {dim, N}
    DFloat = eltype(Q)
    γ::DFloat       = _γ
    p0::DFloat      = _p0
    R_gas::DFloat   = _R_gas
    c_p::DFloat     = _c_p
    c_v::DFloat     = _c_v
    gravity::DFloat = _gravity

    Np = (N+1)^dim
    (~, ~, nelem) = size(Q)

    @inbounds for e = 1:nelem, n = 1:Np
        ρ, u, v, w, E = Q[n, _ρ, e], Q[n, _U, e], Q[n, _V, e], Q[n, _W, e], Q[n, _E, e]
        P = p0 * (ρ * R_gas * E / p0)^(c_p / c_v)
        T = P/(ρ*R_gas)
        E = c_v*T
        Q[n, _U, e] = ρ*u
        Q[n, _V, e] = ρ*v
        Q[n, _W, e] = ρ*w
        Q[n, _E, e] = ρ*E
    end
end

function convert_set4c_to_set2nc(::Val{dim}, ::Val{N}, vgeo, Q) where {dim, N}
    DFloat = eltype(Q)
    γ::DFloat       = _γ
    p0::DFloat      = _p0
    R_gas::DFloat   = _R_gas
    c_p::DFloat     = _c_p
    c_v::DFloat     = _c_v
    gravity::DFloat = _gravity

    Np = (N+1)^dim
    (~, ~, nelem) = size(Q)

    @inbounds for e = 1:nelem, n = 1:Np
        ρ, U, V, W, E = Q[n, _ρ, e], Q[n, _U, e], Q[n, _V, e], Q[n, _W, e], Q[n, _E, e]
        u=U/ρ
        v=V/ρ
        w=W/ρ
        T=E/(ρ*c_v)
        P=ρ*R_gas*T
        E=p0/(ρ* R_gas)*(P/p0)^(c_v/c_p)
        Q[n, _U, e] = u
        Q[n, _V, e] = v
        Q[n, _W, e] = w
        Q[n, _E, e] = E
    end
end</code></pre><pre><code class="language-none">convert_set4c_to_set2nc (generic function with 1 method)</code></pre></div><p>}}}</p><p>{{{ nse driver</p><div><pre><code class="language-julia">function nse(::Val{dim}, ::Val{N}, mpicomm, ic, mesh, tend, iplot, visc;
               meshwarp=(x...)-&gt;identity(x),
               tout = 1, ArrType=Array, plotstep=0) where {dim, N}
    DFloat = typeof(tend)

    mpirank = MPI.Comm_rank(mpicomm)
    mpisize = MPI.Comm_size(mpicomm)</code></pre></div><p>Partion the mesh using a Hilbert curve based partitioning</p><div><pre><code class="language-julia">    mpirank == 0 &amp;&amp; println(&quot;[CPU] partitioning mesh...&quot;)
    mesh = partition(mpicomm, mesh...)</code></pre></div><p>Connect the mesh in parallel</p><div><pre><code class="language-julia">    mpirank == 0 &amp;&amp; println(&quot;[CPU] connecting mesh...&quot;)
    mesh = connectmesh(mpicomm, mesh...)</code></pre></div><p>Get the vmaps</p><div><pre><code class="language-julia">    mpirank == 0 &amp;&amp; println(&quot;[CPU] computing mappings...&quot;)
    (vmapM, vmapP) = mappings(N, mesh.elemtoelem, mesh.elemtoface,
                              mesh.elemtoordr)</code></pre></div><p>Create 1-D operators</p><div><pre><code class="language-julia">    (ξ, ω) = lglpoints(DFloat, N)
    D = spectralderivative(ξ)</code></pre></div><p>Compute the geometry</p><div><pre><code class="language-julia">    mpirank == 0 &amp;&amp; println(&quot;[CPU] computing metrics...&quot;)
    (vgeo, sgeo) = computegeometry(Val(dim), mesh, D, ξ, ω, meshwarp, vmapM)
    (nface, nelem) = size(mesh.elemtoelem)</code></pre></div><p>Storage for the solution, rhs, and error</p><div><pre><code class="language-julia">    mpirank == 0 &amp;&amp; println(&quot;[CPU] creating fields (CPU)...&quot;)
    Q = zeros(DFloat, (N+1)^dim, _nstate, nelem)
    rhs = zeros(DFloat, (N+1)^dim, _nstate, nelem)</code></pre></div><p>setup the initial condition</p><div><pre><code class="language-julia">    mpirank == 0 &amp;&amp; println(&quot;[CPU] computing initial conditions (CPU)...&quot;)
    @inbounds for e = 1:nelem, i = 1:(N+1)^dim
        x, y, z = vgeo[i, _x, e], vgeo[i, _y, e], vgeo[i, _z, e]
        ρ, U, V, W, E = ic(x, y, z)
        Q[i, _ρ, e] = ρ
        Q[i, _U, e] = U
        Q[i, _V, e] = V
        Q[i, _W, e] = W
        Q[i, _E, e] = E
    end</code></pre></div><p>Convert to proper variables</p><div><pre><code class="language-julia">    mpirank == 0 &amp;&amp; println(&quot;[CPU] converting variables (CPU)...&quot;)
    convert_set2nc_to_set3c(Val(dim), Val(N), vgeo, Q)</code></pre></div><p>Compute time step</p><div><pre><code class="language-julia">    mpirank == 0 &amp;&amp; println(&quot;[CPU] computing dt (CPU)...&quot;)
    (base_dt, Courant) = courantnumber(Val(dim), Val(N), vgeo, Q, mpicomm)
    #base_dt=0.02
    mpirank == 0 &amp;&amp; @show (base_dt, Courant)

    nsteps = ceil(Int64, tend / base_dt)
    dt = tend / nsteps
    mpirank == 0 &amp;&amp; @show (dt, nsteps, dt * nsteps, tend)</code></pre></div><p>Do time stepping</p><div><pre><code class="language-julia">    stats = zeros(DFloat, 2)
    mpirank == 0 &amp;&amp; println(&quot;[CPU] computing initial energy...&quot;)
    Q_temp=copy(Q)
    convert_set3c_to_set2nc(Val(dim), Val(N), vgeo, Q_temp)
    stats[1] = L2energysquared(Val(dim), Val(N), Q_temp, vgeo, mesh.realelems)
    @show (sqrt.(stats[1]))</code></pre></div><p>Write VTK file: plot the initial condition</p><div><pre><code class="language-julia">    mkpath(&quot;viz&quot;)
    X = ntuple(j-&gt;reshape((@view vgeo[:, _x+j-1, :]), ntuple(j-&gt;N+1,dim)...,
                          nelem), dim)
    ρ = reshape((@view Q_temp[:, _ρ, :]), ntuple(j-&gt;(N+1),dim)..., nelem)
    U = reshape((@view Q_temp[:, _U, :]), ntuple(j-&gt;(N+1),dim)..., nelem)
    V = reshape((@view Q_temp[:, _V, :]), ntuple(j-&gt;(N+1),dim)..., nelem)
    W = reshape((@view Q_temp[:, _W, :]), ntuple(j-&gt;(N+1),dim)..., nelem)
    E = reshape((@view Q_temp[:, _E, :]), ntuple(j-&gt;(N+1),dim)..., nelem)
    E = E .- 300.0
    writemesh(@sprintf(&quot;viz/nse%dD_set3c_%s_rank_%04d_step_%05d&quot;,
                       dim, ArrType, mpirank, 0), X...;
              fields=((&quot;ρ&quot;, ρ), (&quot;U&quot;, U), (&quot;V&quot;, V), (&quot;W&quot;, W), (&quot;E&quot;, E)),
              realelems=mesh.realelems)

    mpirank == 0 &amp;&amp; println(&quot;[DEV] starting time stepper...&quot;)
    lowstorageRK(Val(dim), Val(N), mesh, vgeo, sgeo, Q, rhs, D, dt, nsteps, tout,
                 vmapM, vmapP, mpicomm, iplot, visc; ArrType=ArrType, plotstep=plotstep)</code></pre></div><p>Write VTK: final solution</p><div><pre><code class="language-julia">    Q_temp=copy(Q)
    convert_set3c_to_set2nc(Val(dim), Val(N), vgeo, Q_temp)
    X = ntuple(j-&gt;reshape((@view vgeo[:, _x+j-1, :]), ntuple(j-&gt;N+1,dim)...,
                          nelem), dim)
    ρ = reshape((@view Q_temp[:, _ρ, :]), ntuple(j-&gt;(N+1),dim)..., nelem)
    U = reshape((@view Q_temp[:, _U, :]), ntuple(j-&gt;(N+1),dim)..., nelem)
    V = reshape((@view Q_temp[:, _V, :]), ntuple(j-&gt;(N+1),dim)..., nelem)
    W = reshape((@view Q_temp[:, _W, :]), ntuple(j-&gt;(N+1),dim)..., nelem)
    E = reshape((@view Q_temp[:, _E, :]), ntuple(j-&gt;(N+1),dim)..., nelem)
    E = E .- 300.0
    writemesh(@sprintf(&quot;viz/nse%dD_set3c_%s_rank_%04d_step_%05d&quot;,
                       dim, ArrType, mpirank, nsteps), X...;
              fields=((&quot;ρ&quot;, ρ), (&quot;U&quot;, U), (&quot;V&quot;, V), (&quot;W&quot;, W), (&quot;E&quot;, E)),
              realelems=mesh.realelems)

    mpirank == 0 &amp;&amp; println(&quot;[CPU] computing final energy...&quot;)
    stats[2] = L2energysquared(Val(dim), Val(N), Q_temp, vgeo, mesh.realelems)

    stats = sqrt.(MPI.allreduce(stats, MPI.SUM, mpicomm))

    if  mpirank == 0
        @show eng0 = stats[1]
        @show engf = stats[2]
        @show Δeng = engf - eng0
    end
end</code></pre><pre><code class="language-none">nse (generic function with 1 method)</code></pre></div><p>}}}</p><p>{{{ main</p><div><pre><code class="language-julia">function main()
    DFloat = Float64</code></pre></div><p>MPI.Init()</p><div><pre><code class="language-julia">    MPI.Initialized() || MPI.Init()
    MPI.finalize_atexit()

    mpicomm = MPI.COMM_WORLD
    mpirank = MPI.Comm_rank(mpicomm)
    mpisize = MPI.Comm_size(mpicomm)</code></pre></div><p>FIXME: query via hostname</p><div><pre><code class="language-julia">    @hascuda device!(mpirank % length(devices()))

    #Initial Conditions
    function ic(dim, x...)</code></pre></div><p>FIXME: Type generic?</p><div><pre><code class="language-julia">        DFloat = eltype(x)
        γ::DFloat       = _γ
        p0::DFloat      = _p0
        R_gas::DFloat   = _R_gas
        c_p::DFloat     = _c_p
        c_v::DFloat     = _c_v
        gravity::DFloat = _gravity

        u0 = 0
        r = sqrt((x[1]-500)^2 + (x[dim]-350)^2 )
        rc = 250.0
        θ_ref=300.0
        θ_c=0.5
        Δθ=0.0
        if r &lt;= rc
            Δθ = 0.5 * θ_c * (1.0 + cos(π * r/rc))
        end
        θ_k=θ_ref + Δθ
        π_k=1.0 - gravity/(c_p*θ_k)*x[dim]
        c=c_v/R_gas
        ρ_k=p0/(R_gas*θ_k)*(π_k)^c
        ρ = ρ_k
        U = u0
        V = 0.0
        W = 0.0
        E = θ_k
        ρ, U, V, W, E
    end

    time_final = DFloat(10.0)
    iplot=100
    Ne = 10
    N  = 4
    visc = 1.0
    dim = 3
    hardware=&quot;cpu&quot;
    @show (N,Ne,visc,iplot,time_final,hardware,mpisize)

    mesh3D = brickmesh((range(DFloat(0); length=Ne+1, stop=1000),
                        range(DFloat(0); length=2, stop=1000),
                        range(DFloat(0); length=Ne+1, stop=1000)),
                       (true, true, false),
                       part=mpirank+1, numparts=mpisize)

    if hardware == &quot;cpu&quot;
        mpirank == 0 &amp;&amp; println(&quot;Running 3d (CPU)...&quot;)
        nse(Val(dim), Val(N), mpicomm, (x...)-&gt;ic(dim, x...), mesh3D, time_final, iplot, visc;
              ArrType=Array, tout = 10)
        mpirank == 0 &amp;&amp; println()
    elseif hardware == &quot;gpu&quot;
        @hascuda begin
            mpirank == 0 &amp;&amp; println(&quot;Running 3d (GPU)...&quot;)
            nse(Val(dim), Val(N), mpicomm, (x...)-&gt;ic(dim, x...), mesh3D, time_final, iplot, visc;
                  ArrType=CuArray, tout = 10)
            mpirank == 0 &amp;&amp; println()
        end
    end
    nothing
end</code></pre><pre><code class="language-none">main (generic function with 1 method)</code></pre></div><p>}}}</p><div><pre><code class="language-julia">main()</code></pre><pre><code class="language-none">(N, Ne, visc, iplot, time_final, hardware, mpisize) = (4, 10, 1.0, 100, 10.0, &quot;cpu&quot;, 1)
Running 3d (CPU)...
[CPU] partitioning mesh...
[CPU] connecting mesh...
[CPU] computing mappings...
[CPU] computing metrics...
[CPU] creating fields (CPU)...
[CPU] computing initial conditions (CPU)...
[CPU] converting variables (CPU)...
[CPU] computing dt (CPU)...
(base_dt, Courant) = (0.025450764705815466, 1.0)
(dt, nsteps, dt * nsteps, tend) = (0.02544529262086514, 393, 10.0, 10.0)
[CPU] computing initial energy...
sqrt.(stats[1]) = 9.487821982268665e6
[DEV] starting time stepper...
(step, nsteps, avg_stage_time) = (104, 393, 0.01471783792815534)
(step, nsteps, avg_stage_time) = (251, 393, 0.014097893772)
(step, nsteps, avg_stage_time) = (387, 393, 0.014330623056476685)
(nsteps, avg_stage_time) = (393, 0.014340595766326531)
[CPU] computing final energy...
eng0 = stats[1] = 9.487821982268665e6
engf = stats[2] = 9.487822045278741e6
Δeng = engf - eng0 = 0.06301007606089115</code></pre></div><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><footer><hr/><a class="previous" href="../LDG3d/"><span class="direction">Previous</span><span class="title">3D Diffusion Equation Example</span></a><a class="next" href="../../../../reference/mesh/"><span class="direction">Next</span><span class="title">Mesh</span></a></footer></article></body></html>
