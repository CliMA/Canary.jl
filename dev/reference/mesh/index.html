<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mesh · Canary.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Canary.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../../manual/dg_intro/">Introduction to DG</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../manual/mesh/">Mesh</a></li><li><a class="toctext" href="../../manual/metric/">Metric Terms</a></li><li><a class="toctext" href="../../manual/operators/">Element Operators</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/generated/advection/">Advection Equation Example</a></li><li><a class="toctext" href="../../examples/generated/shallow_water/">Shallow Water Equations Example</a></li></ul></li><li><span class="toctext">API Reference</span><ul><li class="current"><a class="toctext" href>Mesh</a><ul class="internal"></ul></li><li><a class="toctext" href="../metric/">Metric Terms</a></li><li><a class="toctext" href="../operators/">Element Operators</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>API Reference</li><li><a href>Mesh</a></li></ul><a class="edit-page" href="https://github.com/climate-machine/Canary.jl/blob/master/docs/src/reference/mesh.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Mesh</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Mesh-1" href="#Mesh-1">Mesh</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Canary.brickmesh" href="#Canary.brickmesh"><code>Canary.brickmesh</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">brickmesh(x, periodic; part=1, numparts=1; boundary)</code></pre><p>Generate a brick mesh with coordinates given by the tuple <code>x</code> and the periodic dimensions given by the <code>periodic</code> tuple.</p><p>The brick can optionally be partitioned into <code>numparts</code> and this returns partition <code>part</code>.  This is a simple Cartesian partition and further partitioning (e.g, based on a space-filling curve) should be done before the mesh is used for computation.</p><p>By default boundary faces will be marked with a one and other faces with a zero.  Specific boundary numbers can also be passed for each face of the brick in <code>boundary</code>.  This will mark the nonperiodic brick faces with the given boundary number.</p><p><strong>Examples</strong></p><p>We can build a 3 by 2 element two-dimensional mesh that is periodic in the <span>$x_2$</span>-direction with</p><pre><code class="language-julia-repl">julia&gt; using Canary
julia&gt; (elemtovert, elemtocoord, elemtobndy, faceconnections) =
        brickmesh((2:5,4:6), (false,true); boundary=[1 3; 2 4]);</code></pre><p>This returns the mesh structure for</p><pre><code class="language-none">         x_2

          ^
          |
         6-  9----10----11----12
          |  |     |     |     |
          |  |  4  |  5  |  6  |
          |  |     |     |     |
         5-  5-----6-----7-----8
          |  |     |     |     |
          |  |  1  |  2  |  3  |
          |  |     |     |     |
         4-  1-----2-----3-----4
          |
          +--|-----|-----|-----|--&gt; x_1
             2     3     4     5</code></pre><p>The (number of corners by number of elements) array <code>elemtovert</code> gives the global vertex number for the corners of each element.</p><pre><code class="language-julia-repl">julia&gt; elemtovert
4×6 Array{Int64,2}:
 1  2  3   5   6   7
 2  3  4   6   7   8
 5  6  7   9  10  11
 6  7  8  10  11  12</code></pre><p>Note that the vertices are listed in Cartesian order.</p><p>The (dimension by number of corners by number of elements) array <code>elemtocoord</code> gives the coordinates of the corners of each element.</p><pre><code class="language-jldoctes">julia&gt; elemtocoord
2×4×6 Array{Int64,3}:
[:, :, 1] =
 2  3  2  3
 4  4  5  5

[:, :, 2] =
 3  4  3  4
 4  4  5  5

[:, :, 3] =
 4  5  4  5
 4  4  5  5

[:, :, 4] =
 2  3  2  3
 5  5  6  6

[:, :, 5] =
 3  4  3  4
 5  5  6  6

[:, :, 6] =
 4  5  4  5
 5  5  6  6</code></pre><p>The (number of faces by number of elements) array <code>elemtobndy</code> gives the boundary number for each face of each element.  A zero will be given for connected faces.</p><pre><code class="language-julia-repl">julia&gt; elemtobndy
4×6 Array{Int64,2}:
 1  0  0  1  0  0
 0  0  2  0  0  2
 0  0  0  0  0  0
 0  0  0  0  0  0</code></pre><p>Note that the faces are listed in Cartesian order.</p><p>Finally, the periodic face connections are given in <code>faceconnections</code> which is a list of arrays, one for each connection. Each array in the list is given in the format <code>[e, f, vs...]</code> where</p><ul><li><code>e</code>  is the element number;</li><li><code>f</code>  is the face number; and</li><li><code>vs</code> is the global vertices that face associated with.</li></ul><p>I the example</p><pre><code class="language-julia-repl">julia&gt; faceconnections
3-element Array{Array{Int64,1},1}:
 [4, 4, 1, 2]
 [5, 4, 2, 3]
 [6, 4, 3, 4]</code></pre><p>we see that face <code>4</code> of element <code>5</code> is associated with vertices <code>[2 3]</code> (the vertices for face <code>1</code> of element <code>2</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/Canary.jl/blob/2716fb04dd81b8ef3a47aeb6fbaa375154ab36c2/src/mesh.jl#L143-L258">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Canary.connectmesh" href="#Canary.connectmesh"><code>Canary.connectmesh</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">connectmesh(comm::MPI.Comm, elemtovert, elemtocoord, elemtobndy,
            faceconnections)</code></pre><p>This function takes in a mesh (as returned for example by <code>brickmesh</code>) and returns a connected mesh.  This returns a <code>NamedTuple</code> of:</p><ul><li><code>elems</code> the range of element indices</li><li><code>realelems</code> the range of real (aka nonghost) element indices</li><li><code>ghostelems</code> the range of ghost element indices</li><li><code>sendelems</code> an array of send element indices sorted so that</li><li><code>elemtocoord</code> element to vertex coordinates; <code>elemtocoord[d,i,e]</code> is the  <code>d</code>th coordinate of corner <code>i</code> of element <code>e</code></li><li><code>elemtoelem</code> element to neighboring element; <code>elemtoelem[f,e]</code> is the number of the element neighboring element <code>e</code> across face <code>f</code>.  If there is no neighboring element then <code>elemtoelem[f,e] == e</code>.</li><li><code>elemtoface</code> element to neighboring element face; <code>elemtoface[f,e]</code> is the face number of the element neighboring element <code>e</code> across face <code>f</code>.  If there is no neighboring element then <code>elemtoface[f,e] == f</code>.</li><li><code>elemtoordr</code> element to neighboring element order; <code>elemtoordr[f,e]</code> is the ordering number of the element neighboring element <code>e</code> across face <code>f</code>.  If there is no neighboring element then <code>elemtoordr[f,e] == 1</code>.</li><li><code>elemtobndy</code> element to bounday number; <code>elemtobndy[f,e]</code> is the boundary number of face <code>f</code> of element <code>e</code>.  If there is a neighboring element then <code>elemtobndy[f,e] == 0</code>.</li><li><code>nabrtorank</code> a list of the MPI ranks for the neighboring processes</li><li><code>nabrtorecv</code> a range in ghost elements to receive for each neighbor</li><li><code>nabrtosend</code> a range in <code>sendelems</code> to send for each neighbor</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/Canary.jl/blob/2716fb04dd81b8ef3a47aeb6fbaa375154ab36c2/src/mesh.jl#L710-L739">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Canary.mappings" href="#Canary.mappings"><code>Canary.mappings</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mappings(N, elemtoelem, elemtoface, elemtoordr)</code></pre><p>This function takes in a polynomial order <code>N</code> and parts of a mesh (as returned from <code>connectmesh</code>) and returns index mappings for the element surface flux computation.  The returned <code>Tuple</code> contains:</p><ul><li><p><code>vmapM</code> an array of linear indices into the volume degrees of freedom where <code>vmapM[:,f,e]</code> are the degrees of freedom indices for face <code>f</code> of element  <code>e</code>.</p></li><li><p><code>vmapP</code> an array of linear indices into the volume degrees of freedom where <code>vmapP[:,f,e]</code> are the degrees of freedom indices for the face neighboring face <code>f</code> of element <code>e</code>.</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/Canary.jl/blob/2716fb04dd81b8ef3a47aeb6fbaa375154ab36c2/src/mesh.jl#L935-L949">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Canary.partition" href="#Canary.partition"><code>Canary.partition</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">partition(comm::MPI.Comm, elemtovert, elemtocoord, elemtobndy,
          faceconnections)</code></pre><p>This function takes in a mesh (as returned for example by <code>brickmesh</code>) and returns a Hilbert curve based partitioned mesh.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/Canary.jl/blob/2716fb04dd81b8ef3a47aeb6fbaa375154ab36c2/src/mesh.jl#L492-L498">source</a></section><footer><hr/><a class="previous" href="../../examples/generated/shallow_water/"><span class="direction">Previous</span><span class="title">Shallow Water Equations Example</span></a><a class="next" href="../metric/"><span class="direction">Next</span><span class="title">Metric Terms</span></a></footer></article></body></html>
